(in-package :omega)


(mod~defmod AGPLAN 
            :uses (BLIK OMEGA OTTER atpprb atptop env f2p foci infer just keim logic node omega ot pds pl2p prob res2nd satch socket sugg sys term th type view)
            :documentation "The file provides functionality for agent based theorem proving with external systems."
            :exports (
                      agplan~find-counterexample-by-satchmo
                      agplan~lookup-pds
                      agplan~pds-hashtable
                      agplan~show-orig-pds
                      agplan~show-pds
                      agplan~store-new-pds
                      agplan~tackle-by-fo-atp
                      agplan~tackle-by-leo
		      agplan~tackle-by-leo-pl
                      agplan~tackle-by-pl-atp
                      agplan~tackle-by-tps
		      agplan~copy-pds
		      agplan~matching-term
		      agplan~current-open-node
		      agplan~current-open-node
		      agplan~contained-definition
		      agplan~contained-definitions
		      agplan~negate
		      agplan~str-pos-subf-p
		      agplan~str-pos-subforms
		      agplan~repeated-line-p
		      agplan~define-variables
		      agplan~get-definition&pos
		      agplan~ext-check
		      agplan~pl-like-formula-p
		      ;agplan~pds2outline
		      agplan~simplify-goal-with-cas
		      agplan~simplify-with-cas
		      agplan~name
                      ))

;;; The following functions are internal in other modules and should not be used:
;;; (lc=default-tactic oc=call-leo-get-proof oc=default-auto-pds-names oc=expand-node tps=call-tps)


(defun agplan~pds-hashtable ()
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "None.")
	   (effect  "None.")
	   (value   "The proofs hashtable for proofs automatically found in the background."))
  (foci~pds-hashtable (foci~active-pc)))

(defun agplan~store-new-pds (line prover additional-name pds) 
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "Proof line, name of the prover, additional-name-string, and the pds to store.")
	   (effect  "Modifies agplan*pds-hashtable.")
	   (value   "Inserts a new entry in the agplan*pds-hashtable. The key is line-name*prover*additional-name."))
  (let ((key (string-upcase (format nil "~A*~A*~A" (agplan~name line) prover additional-name))))
    (setf (gethash key (agplan~pds-hashtable)) pds)
    key))

(defun agplan~lookup-pds (name)
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "A string or a symbol.")
	   (effect  "None.")
	   (value   "The entry in the rule/tactic classifier hashtable associated with obj"))
  (if (stringp name) 
      (gethash  (string-upcase name) (agplan~pds-hashtable))
    (when (symbolp name) 
      (gethash (string-upcase (symbol-name name)) (agplan~pds-hashtable)))))


(defun agplan~pds-hashtable-indices ()
  (declare (edited  "22-Sep-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "None.")
	   (value   "All indices of the pds hashtable."))
  (let ((list nil))
    (maphash #'(lambda (x y) (declare (ignore y)) (push x list)) (agplan~pds-hashtable))
    list))


(defun agplan~pds-hashtable-entries ()
  (declare (edited  "22-Sep-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "None.")
	   (value   "All entries of the pds hashtable."))
    (let ((list nil))
      (maphash #'(lambda (x y) (declare (ignore x)) (push y list)) (agplan~pds-hashtable))
      list))


(defun agplan~advertised-proofs (line)
  (declare (edited  "22-Oct-2000")
	   (authors Chris)
	   (input   "A proof line")
	   (effect  "None.")
	   (value   "A list with the names of all (partial) proofs being advertised from external systems for this line."))
  (let ((prooflist (remove-if-not #'(lambda (x) (string< (agplan~name line) x))
				(agplan~pds-hashtable-indices))))
    (omega~message "~% The following is a list of proofs advertised for node ~A ~% ~A~%"
		   (agplan~name line)
		   prooflist)
    prooflist))
		 



(defun agplan~show-pds (name)
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "A string or a symbol.")
	   (effect  "None.")
	   (value   "The entry in the rule/tactic classifier hashtable associated with obj"))
    (let* ((node (pds~label2node name))
	   (res (if node (car (keim~get node 'atp-problems))
		  (agplan~lookup-pds name))))
      (cond ((atpprb~leo-problem-p res) ;;; this means it is a problem generated by leo
	     (progn
	       (view~clean-proof view*view)
	       (mapc #'(lambda (x) (socket~write x :inout))
		     (atpprb~leoloui-proof res))))
	    ((stringp res)             ;;; e.g. in case of a counterexample
	     (omega~trace res))
	    ((pds~proof-plan-p res)
               ;;; dirty hack
	     (let ((omega*current-proof-plan omega*current-proof-plan)
		   (keim::pds*current-proof-plan keim::pds*current-proof-plan))
	       (agplan=show res)
	       (pds~show-proof-plan res))))))


(defun agplan=show (proof-plan)
  (let ((omega*current-proof-plan proof-plan)
	(omega*current-theory (prob~proof-theory proof-plan))
	(logic*current-theory omega*current-theory)
	(keim::pds*current-proof-plan proof-plan))
    (when view*on 
      (view~unhide-proof omega*current-proof-plan)
      (view~clean-proof view*view)
      (view~display-proof omega*current-proof-plan))))



(defun agplan~show-orig-pds ()
  (agplan=show omega*current-proof-plan))


;;;; copied from atp-trans-conversation.lisp, as not exported yet

(defun agplan=new-problem-to-node (open-node pds)
  (declare (edited  "22-JUL-1999")
	   (authors Ameier)
	   (input   "An node to prove and the pds it occurs in.")
	   (effect  "None.")
	   (value   "A new problem, consisting of the open node as conclusion and its supports as assumptions."))
  
  (let* ((new-name (intern (string-upcase (format nil "~A-problem" (agplan~name open-node)))))
	 (pds-env (pds~environment pds))
	 (pds-problem (prob~proof-problem pds))
	 (pds-problem-env (prob~environment pds-problem))
	 (th-env (th~env (prob~theory pds)))
	 (new-env (env~create (list th-env)))
	 (new-conclusion (node~create (agplan~name open-node) (node~formula open-node) (just~create (infer~find-method 'open) nil)))
	 (new-assumptions (mapcar #'(lambda (supp)
				      (node~create (agplan~name supp) (node~formula supp) (just~create (infer~find-method 'hyp) nil)))
				  (remove open-node (pds~node-supports open-node))))
	 (new-problem (prob~create new-name (prob~theory pds) new-env new-assumptions new-conclusion))
	 (all-type-vars (append (env~class-keys pds-env 'type+variable nil)
				(env~class-keys pds-problem-env 'type+variable nil)))
	 (all-type-constants (append (env~class-keys pds-env 'type+constant nil)
				     (env~class-keys pds-problem-env 'type+constant nil)))
	 (all-constants (append (env~class-keys pds-env 'term+constant nil)
				(env~class-keys pds-problem-env 'term+constant nil)))
	 (all-variables (append (env~class-keys pds-env 'term+variable nil)
				(env~class-keys pds-problem-env 'term+variable nil))))

    (mapcar #'(lambda (key)
		(let* ((obj (env~lookup-object key pds-env)))

		  (env~enter key obj new-env)))
	    (append all-type-vars
		    all-type-constants
		    all-constants
		    all-variables))
    
    new-problem))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Different tackle by function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun agplan~tackle-by-pl-atp (line &optional agent-name (time-resource 10))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (omega*current-resolution-proof nil))
    (OC=COMMAND-CALL-PL-ATP-ON-NODE new-line
				   (atptop~default-directory)
				   'AUTO
				   'PARSE
				   'T
				   ""
				   ""
				   time-resource
				   'AUTO
				   NIL
				   NIL
				   2
				   'T
				   'T
				   'CONSTANTS)
    (when OMEGA*CURRENT-RESOLUTION-PROOF  ;;; means that otter has indeed found a proof (is this ok andreas)
      (agplan~store-new-pds new-line :otter (gensym) omega*current-proof-plan))))



;(defun agplan~tackle-by-pl-atp (line)
;  (let ((res-proof (OTTER~CALL-OTTER
;                                       line ; the proof line
;                                       OMEGA*CURRENT-PROOF-PLAN
;                                       (atptop~default-directory) ; the directory 
;                                       1000 ; ressource
;                                       'auto ; mode
;                                       't ; get output
;                                       't ; proof-object
;                                       (string "") ; user-flag-string
;                                       (string "") ; user-weight-string
;                                       :P2PL
;                                       'T)))
;    (when res-proof  ;;; dirty hack
;      (let ((new-pds (agplan~copy-pds omega*current-proof-plan))
;            (new-line (agplan~find-corresponding-open-line line new-pds))
;            (omega*current-proof-plan new-pds)
;            (keim::pds*current-proof-plan new-pds)
;            (foci*in-use nil))
;        (print "Transform Proof")
;        (res2nd~transform res-proof)
;        (f2p~translate omega*current-proof-plan)
;        (agplan~store-new-pds new-line :otter (gensym) new-pds)))))




(defun agplan~tackle-by-tps (line)
  (let* ((new-prob (agplan=new-problem-to-node line omega*current-proof-plan))
	 (new-pds (pds~start-proof-plan new-prob (ot~new-proof-plan-name
						  omega*current-proof-plan)))
	 (omega*current-proof-plan new-pds)
	 (pds*current-proof-plan new-pds)
	 (omega*current-theory (prob~theory new-pds))
	 (logic*current-theory (prob~theory new-pds))
	 (foci*in-use nil)
	 (new-line (pds~label2node (agplan~name line) new-pds)))
    (let ((res (tps=call-tps new-line (format nil "tps-problems-~A" (sys~getenv "USER"))
			     (atptop~default-directory) 60 t "MS88" nil nil)))
      (cond ((equal res :partial-proof) ;;; partial proof
	     (agplan~store-new-pds new-line :tps (gensym) new-pds))
	    ((equal res :complete-proof) ;;; complete proof
	      (let ((view*on nil))
		(oc=expand-node new-line))
	      (agplan~store-new-pds new-line :tps (gensym) new-pds))))))




(defun agplan~find-counterexample-by-satchmo (line)
  (multiple-value-bind (res out-string)
      (satch~call-satchmo line ; the proof line
			  OMEGA*CURRENT-PROOF-PLAN
			  (atptop~default-directory) ; the directory 
			  1000			; ressource
			  )
    (let ((new-pds (when (not res)  ;;; not yet realised)
	       (format nil "~%Satchmo has found a countermodel for line ~A: ~%~A~%" line out-string))))
      (when new-pds 
	(agplan~store-new-pds line :satchmo (gensym) new-pds)))))



(defun agplan~tackle-by-fo-atp (line &optional agent-name (time-resource 10))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (omega*current-resolution-proof nil))
    (OC=COMMAND-CALL-OTTER-ON-NODE new-line
				   (atptop~default-directory)
				   'AUTO
				   'PARSE
				   'T
				   ""
				   ""
				   time-resource
				   'AUTO
				   NIL
				   NIL
				   2
				   'T
				   'T
				   'CONSTANTS)
    (when OMEGA*CURRENT-RESOLUTION-PROOF  ;;; means that otter has indeed found a proof (is this ok andreas)
      (agplan~store-new-pds new-line :otter (gensym) omega*current-proof-plan))))



(defun agplan~tackle-by-leo (line &optional (tactic 'ext-input-recursive)  (time-bound 10))
    (let* ((new-pds (agplan~copy-pds))
	   (new-line (agplan~find-corresponding-open-line line new-pds))
	   ;; is the first in this list really the current open
	   ;; node, i.e. the copy of 'line'?
	   (omega*current-proof-plan new-pds)
	   (keim::pds*current-proof-plan new-pds)
	   (foci*in-use nil))
      ; (sleep 1)  ;;; kann spaeter wieder weg
      (let ((res (oc=call-leo-on-node new-line tactic time-bound (list 'typed-set))))
	(cond ((eq res :leopartial)
	       (agplan~store-new-pds new-line :leopartial (gensym) omega*current-proof-plan))
	      ((eq res :leo)
	       (agplan~store-new-pds new-line :leo (gensym) omega*current-proof-plan))))))

(defun agplan~tackle-by-leo-pl (line &optional (tactic 'ext-input-recursive)  (time-bound 0))
    (let* ((new-pds (agplan~copy-pds))
	   (new-line (agplan~find-corresponding-open-line line new-pds))
	   ;; is the first in this list really the current open
	   ;; node, i.e. the copy of 'line'?
	   (omega*current-proof-plan new-pds)
	   (keim::pds*current-proof-plan new-pds)
	   (foci*in-use nil))
      ; (sleep 1)  ;;; kann spaeter wieder weg
      (let ((res (oc=call-leo-on-node new-line tactic time-bound nil)))
	(cond ((eq res :leopartial)
	       nil)
	      ((eq res :leo)
	       (agplan~store-new-pds new-line :leo (gensym) omega*current-proof-plan))))))      

(defun agplan~find-corresponding-open-line (open-line pds)
  (let ((all-open-lines (pds~open-nodes pds)))
    (find-if #'(lambda (x) (equal (intern (agplan~name open-line)) (intern (agplan~name x))))
	  all-open-lines)))

(defun agplan~copy-pds (&optional pds*current-proof-plan)
  (let ((path (pathname (format nil "/tmp/~A" (gensym "pds")))))
    (oc=write-pds path t)
    (let ((pname (pathname (format nil "~A.pds" path))))
      (sys~handler-case
       (with-open-file (in pname :direction :input
			   :if-does-not-exist :error)
		       (let* ((list (read in))
			      (newobj (post~read-object (append (list (car list) nil) (cdr list))
							(env~create)
							nil))
			      (new-plan (ot~read-proof-plan newobj)))
			 (delete-file pname)
			 new-plan))
       (file-error (c) (inter~print-error (comint~interface
					   comint*current-comint) c))))))
       


(defun agplan~apply-advertised-pds (name)
  (let ((pds (agplan~lookup-pds name)))
    (when pds
      (foci~compute-pcs :pds pds)
      (oc=prove pds)
      )))

(defun agplan~best-advertised-proof ()
  (car (agplan~best-advertised-proofs)))
 
(defun agplan~best-advertised-proofs ()
  (sort (agplan~advertised-proofs (car (pds~open-nodes omega*current-proof-plan)))
	#'agplan~proof-priorisation-heuristics  ;;; bis jetzt gucke ich nur auf Namen; LEO wird priorisiert
	))

(defun agplan~proof-priorisation-heuristics (x y)
  (declare (ignore y))
  (string< (format nil "~A*~A" (agplan~name (car (pds~open-nodes omega*current-proof-plan))) :LEO) x))

;;;; New commands, which should go into other files later

(com~defcommand show-names-of-advertised-proofs
  (argnames node)
  (argtypes ndline)
  (arghelps "Node to prove with LEO")
  (frag-cats extern)
  (function agplan~advertised-proofs)
  (defaults ((oc~default-current-planline)))
  (log-p T)
  (help ""))


(com~defcommand show-advertised-proof
  (argnames name)
  (argtypes string)
  (arghelps "A string referring to the automatically found proof or a node that
has been automatically proven.")
  (frag-cats extern)
  (function agplan~show-pds)
  (defaults ((agplan~best-advertised-proof)))
  (log-p T) 
  (help ""))


(com~defcommand show-original-proof
  (argnames )
  (argtypes )
  (arghelps )
  (frag-cats extern)
  (function agplan~show-orig-pds)
  (defaults )
  (log-p T) 
  (help ""))

       
(com~defcommand apply-advertised-proof
  (argnames name)
  (argtypes string)
  (arghelps "A string referring to the automatically found proof or a node that
has been automatically proven.")
  (frag-cats extern)
  (function agplan~apply-advertised-pds)
  (defaults ((agplan~best-advertised-proof)))
  (Log-p T) 
  (help ""))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   Categories ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(com~defcategory false
		 (help "Commands dealing with the falsehood."))

(com~defcategory definition
		 (help "Commands dealing with expansion or contraction of definitions."))

(com~defcategory nic-special-tactic
		 (help "Commands dealing with special (additional) tactics for NIC, that
                        are not belonging to the core calculus."))

(com~defcategory dummy
		 (help "Commands dealing with dummy rules."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; additional stuff ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun agplan~matching-term (term1 term2)
  (declare (edited  "07-DEC-2000")
	   (authors Achim)
	   (input   "Two terms.")
	   (effect  "None.")
	   (value   "If the terms match in exactly one sub-term, the codomain of the corresponding"
		    "matching substitution. O/w NIL."))
  (let ((subst (term~alpha-match term1 term2)))
    (when (and subst (= 1 (length (subst~domain subst))))
      (car (subst~codomain subst)))))


(defun agplan~current-open-node ()
   (foci~focus-line (foci~active-pc))) 


(defun agplan~current-proof-plan ()
  keim::pds*current-proof-plan
  )

(defun agplan~contained-definition (formula)
  (declare (edited  "17-APR-1998")
           (authors Chris)
           (input   "A formula")
           (effect  "None")
           (value   "The first definition within term"))
 (car (agplan~contained-definitions formula)))


(defun agplan~contained-definitions (formula)
  (declare (edited  "17-APR-1998")
           (authors Chris)
           (input   "A formula")
           (effect  "None")
           (value   "The definitions within term"))
  (let* ((poslist (data~positions formula #'(lambda (x) (and (term~constant-p x)
							     (th~find-assumption
							      (agplan~name x)
							      (prob~theory omega*current-proof-plan))))))
         (constants
	  (remove-if
	   #'(lambda (x) (or (keim~equal "FORALL" (agplan~name x))
			     (keim~equal "EXISTS" (agplan~name x))
			     (keim~equal '= (agplan~name x))))
	   (remove-duplicates
	    (mapcar #'(lambda (pos) (data~struct-at-position formula pos))
		    poslist) :test #'keim~equal)))
	 (defs (mapcar #'(lambda (x)
			   (th~find-assumption (agplan~name x)
					       (prob~theory omega*current-proof-plan)))
		       constants)))
    defs))


(defun agplan~negate (formula)
  (when (term~p formula)
    (term~appl-create (logic~negation-constant) (list formula))))



(defgeneric agplan~str-pos-subf-p (obj1 obj2 &optional bindables extract-info)
  (declare (edited  "28-12-99")
	   (authors Chris)
	   (input   "Two objects, where obj1 is a node or a formula and obj2 a"
		    "node, formula or a list nodes or formulas. (Furthermore, Optionally a list of"
		    "bindable variables and an extraction information.")
	   (effect  "None.")
	   (value   "A list containing list of:"
		    "precise extraction information (list of command names (+ additional info)"
		    "and a node"))
  (:method ((obj1 node+node) obj2 &optional bindables extract-info)
	   (agplan~str-pos-subf-p (node~formula obj1) obj2 bindables extract-info))
  (:method (obj1 (obj2 list) &optional bindables extract-info)
	   (mapcan #'(lambda (x) (agplan~str-pos-subf-p obj1 x bindables extract-info))
		   obj2))
  (:method (obj1 (obj2 node+node) &optional bindables extract-info)
	   (agplan~str-pos-subf-p obj1 (node~formula obj2) bindables (cons (agplan~name obj2) extract-info)))
  (:method ((obj1 term+term) (obj2 term+term) &optional bindables extract-info)
	   (let ((res-weaken (let ((subst (term~alpha-unify obj2 obj1)))
			       (when subst
				 ;(not (set-difference (subst~domain subst) bindables
				 ;      :test #'data~equal)))
				 (list (cons (list :WEAKEN subst) extract-info)))))
		 (res-conj (when (logic~conjunction-p obj2) ; A <= (A and B); A <= (B and
							    ; A)
			     (append
			      (agplan~str-pos-subf-p obj1
						  (first (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-AND-E-l extract-info))
			      (agplan~str-pos-subf-p obj1
						  (second (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-AND-E-r extract-info)))))
		 (res-disj (when (logic~disjunction-p obj2) ; A <= (A or B); A <= (B or A)
			     ;; extend this part by introducing all possible formulas C
			     (append 
			      (agplan~str-pos-subf-p obj1
						  (first (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-OR-E-l extract-info))
			      (agplan~str-pos-subf-p obj1
						  (second (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-OR-E-r extract-info)))))
		 (res-imp (when (logic~implication-p obj2) ; A <= (B implies A)
			    ;; extend this by introducing all possible formulas A
			    (append 
			     (agplan~str-pos-subf-p obj1
						 (second (data~appl-arguments obj2))
						 bindables
						 (cons :NIC-IMP-E extract-info)))))
		 (res-all (when (logic~universal-quantification-p obj2) ; A(t) <= ALL x . A(x) for every
					                                ; term t
			    (let ((bound-var (logic~quantification-bound-variable obj2)))
			      (agplan~str-pos-subf-p obj1
						  (logic~quantification-scope obj2)
						  (cons bound-var bindables)
						  (cons (list :NIC-FORALL-E bound-var)
							(cons (LIST :DECLARE `(variables
									       (,bound-var
										,(data~annotation bound-var)
										)))
							      extract-info))))))
		 (res-ex (when (logic~existential-quantification-p obj2) ; A(t) <= EX x . A(x) for
				                                         ;  every term t

			   ;; How to handle skolemization
			   (multiple-value-bind (new-obj2 skolemterms)
			       (hocnf~skolemize (logic~quantification-scope obj2)
						(list (logic~quantification-bound-variable obj2))
						(foci~free-vars (foci~active-pc))
						(pds~environment (test=current-proof-plan)))
			     (agplan~str-pos-subf-p obj1 new-obj2 bindables
						 (cons (list :NIC-EXISTS-E-e (car skolemterms)) extract-info))))))
	     (append res-weaken res-conj res-disj res-imp res-all res-ex))))



(defgeneric agplan~str-pos-subforms (obj1)
  (declare (edited  "28-12-99")
	   (authors Chris)
	   (input   "An objects, which is a list, node or a formula")
	   (effect  "None.")
	   (value   "A list containing of strictly positive subformulas of obj1"))
  (:method ((obj1 list))
	   (remove-duplicates (mapcan #'agplan~str-pos-subforms obj1) :test #'keim~equal))
  (:method ((obj1 node+node))
	   (agplan~str-pos-subforms (node~formula obj1)))
  (:method ((obj1 term+term))
	   (cond ((logic~atom-p obj1) (list obj1))
		 ((logic~negation-p obj1) (list obj1))
		 ((logic~conjunction-p obj1) ; A <= (A and B); A <= (B and
					; A)
		  (cons obj1
			(append
			 (agplan~str-pos-subforms (first (data~appl-arguments obj1)))
			 (agplan~str-pos-subforms (second (data~appl-arguments obj1))))))
		 ((logic~disjunction-p obj1) ; A <= (A or B); A <= (B or A)
		  ;; extend this part by introducing all possible formulas C
		  (cons obj1
			(append 
			 (agplan~str-pos-subforms (first (data~appl-arguments obj1)))
			 (agplan~str-pos-subforms (second (data~appl-arguments obj1))))))
		 ((logic~implication-p obj1) ; A <= (B implies A)
		  ;; extend this by introducing all possible formulas A
		  (cons obj1
			(agplan~str-pos-subforms (second (data~appl-arguments obj1)))))
		 ((logic~universal-quantification-p obj1) ; A(t) <= ALL x . A(x) for every
					; term t
		  (cons obj1
			(agplan~str-pos-subforms (logic~quantification-scope obj1))))
		 ((logic~existential-quantification-p obj1) ; A(t) <= EX x . A(x) for
					;  every term t
		  (cons obj1
			(agplan~str-pos-subforms (hocnf~skolemize (logic~quantification-scope obj1)
							       (list (logic~quantification-bound-variable obj1))
							       (foci~free-vars (foci~active-pc))
							       (pds~environment
								(test=current-proof-plan)))))))))



(defgeneric agplan~repeated-line-p (obj)
  (declare (edited  "29-12-99")
           (authors Chris)
           (input   "A proof line or a formula.")
           (effect  "None.")
           (value   "T, iff line is a repeated proof line or formula in proof search."))
  (:method ((obj node+node))
	   (some #'(lambda (x)
		      (and (term~alpha-equal (node~formula x) (node~formula obj))
			   ; (subsetp (pdsn~hyps obj) (pdsn~hyps x))
			   (or (not (nic~elimination-p x)) (nic~elimination-p obj))))
		  (let ((descendants (foci~descendants (foci~active-pc)))
			(supports (pds~node-supports (foci~focus-line (foci~active-pc)))))
		   (append (when descendants (rest descendants)) supports)))) ;;; the first descendant may
							    ;;; be identical to the
							    ;;; current goal, see or-e
  (:method ((obj term+term))
	   (some #'(lambda (x) (term~alpha-equal (node~formula x) obj))
		 (let ((descendants (foci~descendants (foci~active-pc)))
		       (supports (pds~node-supports (foci~focus-line (foci~active-pc)))))
		   (append (when descendants (rest descendants)) supports)))))
                                                             ;;; the first descendant may
							     ;;; be identical to the
							     ;;; current goal, see or-e

(defun agplan~define-variables (term)
  (declare (edited  "10-MAY-2000")
	   (authors Ceb)
	   (input   "A term")
	   (effect  "Declares the free variables of term in the environment")
	   (value   "Undefined"))
  (let* ((variables (term~free-variables term))
	 (form (mapcar #'(lambda  (x) (list x (data~annotation x)))
		       variables)))
    (post~read-object (cons 'variables form)
		      (pds~environment omega*current-proof-plan) nil)))
  

(defun agplan~get-definition&pos (line)
  (let ((definition (agplan~contained-definition line)))
    (values
     definition
     (let* ((definition (th~definition-constant definition))
	    (definition (if (data~schema-p definition)
			    (data~schema-range definition)
			  definition)))
       (car
	(data~substruct-positions 
	 definition
	 line))))))


(defun agplan~ext-check (all-term eq-term)
  (when (and (logic~equality-p eq-term)
	     (logic~universal-quantification-p all-term))
    (let* ((left (car (data~appl-arguments eq-term)))
	   (right (cadr (data~appl-arguments eq-term)))
	   (eq (data~appl-function eq-term))
	   (bound (logic~quantification-bound-variable all-term))
	   (scope (logic~quantification-scope all-term))
	   (new-left (data~appl-create left (list bound)))
	   (new-right (data~appl-create right (list bound))))
      (and (logic~equality-p scope)
	   (data~equal (car (data~appl-arguments scope)) new-left)
	   (data~equal (cadr (data~appl-arguments scope)) new-right)))))


(defmethod bb~command-suggestion-leq-p
  ((sugg1 bb+command-suggestion) (sugg2 bb+command-suggestion) (indicator (eql :i-e-f-demo)))
  (let ((com1 (mapcar #'agplan~name (com~categories (bb~entry-command sugg1))))
	(com2 (mapcar #'agplan~name (com~categories (bb~entry-command sugg2)))))
    (flet ((in (cat list)
	       (find cat list :test #'string-equal)))
      (or (in :extern com2)
	  (and (in :nic-special-tactic com2) (not (in :extern com1)))
	  (and (in :quantifier com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)))
	  (and (in :definition com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1)))
	  (and (in :elimination com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)))
	  (and (in :introduction com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)) (not (in :elimination com1)))
	  (and (in :false com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :elimination com1)) (not (in :definition com1))
	       (not (in :introduction com1)))))))


(defun agplan~pl-like-formula-p (formula)
  (let ((substructs (data~all-substructs formula)))
    (not (find-if #'(lambda (x) (or (term~variable-p x) (logic~equality-p x)
				    (when (term~constant-p x)					  
				      (th~find-assumption (agplan~name x)
							  (prob~theory omega*current-proof-plan)))))
		  substructs))))


(defvar pds*outlines nil)

(defvar agplan*justification-command-hashtable (make-hash-table :test #'equal)
  "Hash table, indexed by justification name, that holds names of corresponding rules/tactics.")

(defun agplan~justification-command-hashtable ()
  (declare (edited  "06-JAN-2000")
	   (authors Chris)
	   (input   "None.")
	   (effect  "None.")
	   (value   "The justofication command hashtable."))
  agplan*justification-command-hashtable)

(defun agplan~set-up-justification-command-hashtable ()
  (declare (edited  "06-JAN-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "Sets up the justification-command-hashtable.")
	   (value   "The  justification-command-hashtable."))
  (setf (gethash (string-upcase "NIC-FORALL-I") (agplan~justification-command-hashtable)) "NICTAC-FORALL-I")
  (setf (gethash (string-upcase "PL-ATP") (agplan~justification-command-hashtable)) "CALL-PL-ATP-ON-NODE")
  (setf (gethash (string-upcase "COUNTEREXAMPLE-WITH-SATCHMO") (agplan~justification-command-hashtable)) "CALL-SATCHMO-ON-NODE")
  (agplan~justification-command-hashtable))

(agplan~set-up-justification-command-hashtable)

(defun agplan~find-corresponding-command (com)
  (let* ((com-name (if (stringp com) (string-upcase com) (string-upcase (format nil "~A" com))))
	 (res (gethash  (string-upcase com-name) (agplan~justification-command-hashtable))))
    (if res res com-name)))



(defun agplan~simplify-goal-with-cas (line &optional (pds PDS*CURRENT-PROOF-PLAN))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (new-hyps (leo~direct-supports new-line))
	 (simpl-new-hyps
	  (mapcar #'(lambda (x) (first (infer~compute-outline 'simplify-with-cas (list nil x)
						       nil)))
		  new-hyps))
	 (simpl-new-line
	  (second (infer~compute-outline 'simplify-with-cas (list new-line nil)
					 nil))))
    (when (or simpl-new-line
	      (find-if #'(lambda (x) (not (nullp x))) simpl-new-hyps))
      (agplan~store-new-pds new-line :simplify (gensym) omega*current-proof-plan))))
  
    


(defun agplan~simplify-with-cas (obj &optional (typelist (list 'num 'o))
				     (vars nil)
				     (env (pds~environment PDS*CURRENT-PROOF-PLAN)))
  (declare (edited  "28-11-00")
           (authors Chris)
           (input   "A formula; optionally a typelist (those two ehich the
CAS might be applied), list of bound vars, and an environment.")
           (effect  "None.")
           (value   "The simplified formula"))
  (let ((type (data~annotation obj)))
    (if (and (find (format nil "~A" type) typelist :test #'string-equal)
	     (not (data~positions obj #'(lambda (x)
					  (or (term~abstr-p x)
					      (and (term~variable-p x)
						   (find x vars)))))))
	(let* ((back (casex~compute-with-maple "simplify" obj))
	       ;;; use (rcl~call-maple (list "simplify" obj) :syntax 'post2post)
	       ;;; see volkers file restclass.lisp
	       (res  (when back (post~read-object back env :existing-term))))
	  (if (or (null res)
		  (and (stringp res) (string-equal res "error")))
	      obj
	    res))
      (cond ((term~appl-p obj)
	     (term~appl-create
	      (agplan~simplify-with-cas (data~appl-function obj) typelist vars env)
	      (mapcar #'(lambda (x) (agplan~simplify-with-cas x typelist vars env))
		      (data~appl-arguments obj))))
	    ((term~abstr-p obj)
	     (term~abstr-create
	      (data~abstr-domain obj)
	      (agplan~simplify-with-cas
	       (data~abstr-range obj) typelist
	       (append (data~abstr-domain obj) vars) env)))
	    ((term~primitive-p obj) obj)))))


(defun agplan~name (obj)   ;;; introduced because agplan~name liefert bei numerals
			   ;;; numbers zuerueck, Bsp. (keim~name 20) --> number
			   ;;; 20
  (format nil "~A" (keim~name obj)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Automatically generating a large testbed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun agplan~generate-set-examples (num-of-vars depth &optional
						 (set-ops (list 'union 'intersection 'setminus)))
  (declare (edited  "21-DEC-2000")
	   (authors Sorge Chris)
	   (input   "Two integers indicating the number of variables and the nesting depth for"
		    "the construed expressions. Optionally a list of set operations.")
	   (effect  "None.")
	   (value   "A list of post expressions."))
  (let* ((vars (do ((num 1 (1+ num))
		    (varlist nil (acons num (read-from-string (format nil "x~A" num)) varlist)))
		   ((> num num-of-vars) (reverse varlist))))
	 (terms-of-depth-n (agplan=construe-terms-of-depth-n vars set-ops depth)))
    (do* ((i 0 (1+ i))
	  (result nil
		  (append result (list (agplan=formulate-problem (pop terms-of-depth-n) i)))))
	((null terms-of-depth-n) result))))

(defun agplan=formulate-problem (conc n)
  (declare (edited  "23-DEC-2000")
	   (authors Sorge)
	   (input   "A formula and an integer.")
	   (effect  "None.")
	   (value   "A problem formulation with the given formula as conclusion."))
  (let ((name (read-from-string (format nil "set-ex-~A" n))))
    (list 'th\~defproblem name '(in typed-set)
	  (list 'conclusion 'conc conc))))

(defun agplan=construe-terms-of-depth-n (vars set-ops depth)
  (let* ((permutations (cdr (agplan=explicit-permutations (length vars) depth)))
	 (operation-list (agplan=make-operation-permutations set-ops (1- depth)))
	 (combined-list (agplan=combine-variables&operations permutations operation-list))
	 (terms (mapcan #'(lambda (pair) (agplan=build-terms pair vars)) combined-list)))
    (mapcar #'(lambda (pair)
		(agplan=add-all-quantification (first pair) (second pair)))
	    terms)))

(defun agplan=add-all-quantification (term variables)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A term and a list of variables.")
	   (effect  "None.")
	   (value   "The term with all quantification over the given variables."))
  (if variables
      (list 'forall (list 'lam (list (car variables) '(o i))
			  (agplan=add-all-quantification term (cdr variables))))
    term))
	  

(defun agplan=build-terms (pair var-mapping)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A list pairing variable permutations and operation permutations.")
	   (effect  "None.")
	   (value   "A list of pairs containing a term and its occurring variables."))
  (let ((vars (first pair))
	(ops (mapcan #'agplan=split-at-equality (second pair))))
    (mapcar #'(lambda (p)
		(agplan=insert-correct-variables (second p) (first p) var-mapping))
	    (agplan=cross-product vars ops))))

(defun agplan=insert-correct-variables (term-structure vars var-mapping)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A term structure, a list of numbers and a association list mapping numbers to variables.")
	   (effect  "None.")
	   (value   "A pair consisting of the substituted term and the variables in the term."))
  (let* ((varlist (mapcar #'(lambda (x) (cdr (assoc x var-mapping :test #'=))) vars))
	 (bkpvl (sort (remove-duplicates varlist) #'string<)))
    (labels ((subst-term (term)
			 (cond ((null term) nil)
			       ((consp term) (mapcar #'subst-term term))
			       ((equal term '*) (pop varlist))
			       (t term))))
      (list (subst-term term-structure) bkpvl))))

(defun agplan=split-at-equality (ops)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A list of operations.")
	   (effect  "None.")
	   (value   "A list of terms."))
  (let* ((pos (position '= ops :test #'string-equal))
	(l1 (subseq ops 0 pos))
	(l2 (subseq ops (1+ pos)))
	(lterms (agplan=bracket-term l1))
	(rterms (agplan=bracket-term l2)))
    (cond ((and (null lterms) (null rterms))
	   '((= * *)))
	  ((null lterms)
	   (mapcar #'(lambda (term) (list '= '* term)) rterms))
	  ((null rterms)
	   (mapcar #'(lambda (term) (list '= term '*)) lterms))
	  (t (mapcar #'(lambda (pair)
			 (list '= (car pair) (cadr pair)))
		     (agplan=cross-product lterms rterms))))))

(defun agplan=bracket-term (ops)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A list of operations.")
	   (effect  "None.")
	   (value   "A list of terms bracketed in all possible ways."))
  (cond ((null ops) nil)
	((null (cdr ops)) (list (list (car ops) '* '*)))
	((null (cddr ops))
	 (let ((fop (car ops))
	       (result (car (agplan=bracket-term (cdr ops)))))
	   (list (list fop '* result) (list fop result '*))))
	(t (let* ((poslists (agplan=split-in-pairs (cdr ops)))
		  (result (mapcar #'(lambda (x)
				      (list (agplan=bracket-term (car x))
					    (agplan=bracket-term (cadr x))))
				  poslists))
		  (fop (car ops)))
	     (mapcan #'(lambda (pair)
			 (if (null (second pair))
			     (mapcan #'(lambda (elem)
					 (list (list fop '* elem)
					       (list fop elem '*)))
				     (first pair))
			   (mapcar #'(lambda (npair)
				       (list fop (first npair) (second npair)))
				   (agplan=cross-product (first pair) (second pair)))))
		     result)
	     ))))


(defun agplan=cross-product (list1 list2)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge Chris)
	   (input   "Two lists.")
	   (effect  "None.")
	   (value   "A list containing the cross product of the two lists."))
  (cond ((null list1) list2)
	((null list2) list1)
	(t (mapcan #'(lambda (x)
		       (mapcar #'(lambda (y) (list x y))
			       list2))
		   list1))))
  

(defun agplan=split-in-pairs (list)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A list.")
	   (effect  "None.")
	   (value   "A list of pairs consisting of the input lists split in all possible two subsets."))
  (do* ((i 0 (1+ i))
	(reslist nil (cons (list (subseq list 0 i)
				 (subseq list i))
			   reslist)))
      ((= i (length list)) reslist)))

(defun agplan=combine-variables&operations (vars ops)
  (declare (edited  "22-DEC-2000")
	   (authors Sorge)
	   (input   "A list of variable permutations and a list of operations permutations.")
	   (effect  "None.")
	   (value   "A pair list of variable permutations and operations permutations that can be combined."))
  (when (and vars ops)
    (let* ((length (length (car vars)))
	   (var-pos (position-if #'(lambda (x) (> (length x) length)) vars))
	   (var-list (if var-pos (subseq vars 0 var-pos) vars))
	   (op-pos (position-if #'(lambda (x) (= (length x) length)) ops))
	   (op-list (if op-pos (subseq ops 0 op-pos) ops)))
      (cons (list var-list op-list)
	     (agplan=combine-variables&operations
	      (subseq vars (length var-list))
	      (subseq ops (length op-list)))))))

(defun agplan=make-operation-permutations (ops depth)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A list of operations and an integer.")
	   (effect  "None.")
	   (value   "A list of operation permutations including equality."))
  (agplan=add-equality-to-perms
   (do* ((i 0 (1+ i))
	 (result (list nil)
		 (append result (agplan=make-permutation-of-length ops i))))
       ((= i (1- depth)) result))))



(defun agplan=add-equality-to-perms (oplist)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A list of permutation list of operations.")
	   (effect  "None.")
	   (value   "The expanded list where equality is placed in each possible position."))
  (when oplist
    (append (agplan=add-equality-to-single-perm (car oplist))
	    (agplan=add-equality-to-perms (cdr oplist)))))

(defun agplan=add-equality-to-single-perm (opperm &optional (equality '=))
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A permutation of operations.")
	   (effect  "None.")
	   (value   "The expanded permutation where equality is placed in each possible position."))
  (flet ((insert-at-pos (n)
			(cond ((= n 0) (cons equality opperm))
			      ((< n (length opperm)) (append (subseq opperm 0 n)
							     (cons equality (subseq opperm n))))
			      (t (append opperm (list equality))))))
    (do* ((i (length opperm) (1- i))
	  (result (list (insert-at-pos i))
		  (cons (insert-at-pos i) result)))
	((= i 0) result))))

(defun agplan=make-permutation-of-length (elems length)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A list of elements of the permuation and its length.")
	   (effect  "None.")
	   (value   "A list of permutations of the elements of given length."))
  (if (> length 1)
      (let ((result (agplan=make-permutation-of-length elems (1- length))))
	(apply #'append
	       (mapcar #'(lambda (x)
			   (mapcar #'(lambda (y) (cons y x))
				   elems))
		       result)))
    (mapcar #'list elems)))
	
(defun agplan=explicit-permutations (n depth)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "Two integers with N>=1 and DEPTH>=2.")
	   (effect  "None.")
	   (value   "A list of permutations of length DEPTH with N different elements."))
  (cond ((= depth 0) nil)
	((= depth 1) (list (list 1)))
	(t (let ((result (agplan=explicit-permutations n (1- depth))))
	     (append result
		     (agplan=single-explicit-permutation 
		      (remove-if-not #'(lambda (x) (= (length x) (1- depth))) result)
		      n))))))

(defun agplan=single-explicit-permutation (perms n)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A list of permutations and an integer.")
	   (effect  "None.")
	   (value   "The extended list of permutations."))
  (when perms
    (append (agplan=extend-permutation (car perms) n)
	      (agplan=single-explicit-permutation (cdr perms) n))))

(defun agplan=extend-permutation (perm n)
  (declare (edited  "21-DEC-2000")
	   (authors Sorge)
	   (input   "A single permutation and an integer.")
	   (effect  "None.")
	   (value   "A list of all possible extensions of the permutation."))
  (let* ((different (length (remove-duplicates perm :test #'=)))
	 (extlist (do* ((i 0 (1+ i))
			(reslist nil (cons i reslist)))
		      ((or (= i (1+ different)) (= i n)) (reverse reslist)))))
    (mapcar #'(lambda (x) (append perm (list x))) extlist)))

#+old(defun agplan~generate-set-examples (num-of-vars depth &optional
						 (set-constructors (list 'union
									 'intersection 'setminus)))
  (omega~message "~%Automatically generate set examples. Number of variables ~A,
Construction depth ~A, Constructors ~A" num-of-vars depth set-constructors)
  (let* ((type (type~abstract (type~o) (list (type~i))))
	 (vars (do ((num 1 (incf num))
		    (varlist (list (term~variable-create (gensym "x-") type))
			     (cons (term~variable-create (gensym "x-") type)
				   varlist)))
		   ((>= num num-of-vars) varlist)))
	 (theory (th~find-theory 'typed-set))
	 (proper-set-constrs (mapcar #'(lambda (x) (th~definition-constant
						    (th~find-assumption x theory)))
				     set-constructors))
	 (left-right-terms (agplan=generate-set-examples vars proper-set-constrs 1 depth))
	 (equations (mapcan #'(lambda (x)
				(mapcar #'(lambda (y)
					    (term~appl-create (logic~equality-constant
							       :theory (th~find-theory 'base)) (list x y)))
					left-right-terms))
			    left-right-terms))
	 (universal-formulas
	  (mapcar #'(lambda (x)
		      (let ((formula x))
			(dolist (var (term~free-variables formula) formula)
			  (setf formula
				(logic~quantification-create
				 (logic~universal-quantor :theory (th~find-theory 'base))
				 var
				 formula)))))
		  equations)))
    (remove-duplicates universal-formulas :test #'keim~equal)))
								
	       
#+old(defun agplan=generate-set-examples (base-terms constructor-terms-2ary depth
						max-depth)
  (omega~message "~%Generating the terms of depth ~A" depth)
  (if (>= depth max-depth) base-terms
    (let ((terms-of-next-depth
	   (append 
	    (remove-duplicates
	     (mapcan #'(lambda (x)
			 (mapcan #'(lambda (y)
				     (mapcar #'(lambda (z)
						 (term~appl-create x (list y z)))
					     base-terms))
				 base-terms))
		     constructor-terms-2ary)
	     :test #'keim~equal)
	    base-terms)))
      (omega~message " Done.")
      (agplan=generate-set-examples terms-of-next-depth constructor-terms-2ary (incf depth) max-depth))))
  
#+old(defun agplan~generate-examples-in-post-syntax (num-of-vars depth filename)
  (let* ((examples (agplan~generate-set-examples num-of-vars depth))
	 (length (length examples)))
    (multiple-value-bind (writelist call-list)
	(do* ((count 1 (incf count))
	      (examples examples (cdr examples))
	      (ex    (post~print (car examples) nil)
		     (post~print (car examples) nil))
	      (name (intern (format nil "set-auto-~A" count))
		    (intern (format nil "set-auto-~A" count)))
	      (post-list (list (list 'th\~defproblem name '(in typed-set) (list 'conclusion 'conc ex)))
			 (cons (list 'th\~defproblem name '(in typed-set) (list 'conclusion 'conc ex))
			       post-list))
	      (call-functions (list (list 'defun name '() (list
							   'oc=prove-pre (list 'prob~find-problem  (format nil "'~A" name)))
					  '(auto~prove)))
			      (cons (list 'defun name '() (list
							   'oc=prove-pre (list 'prob~find-problem (format nil "'~A" name)))
					  '(auto~prove))
				    call-functions))
	      (commands       (list (list 'com~defcommand name '(argnames) '(argtypes) '(arghelps) '(frag-cats extern)
					  (list (format nil "~A" 'function) name) '(log-p T) '(help "")))
			      (cons (list 'com~defcommand name '(argnames) '(argtypes) '(arghelps) '(frag-cats extern)
					  (list (format nil "~A" 'function) name) '(log-p T) '(help ""))
				    commands))
	      (calls          (list (format nil "extern ~A" name)  (format nil "extern wait (10)"))
			      (cons (format nil "extern ~A" name)
				    (cons (format nil "extern wait (10)")
					  calls))))
	    ((>= count length) (values (append post-list
					       call-functions
					       commands)
				       calls))
	  (omega~message " Example ~A: ~A" name ex))
      (let* ((pathname (pathname filename))
	     (stream (open pathname :direction :output
			   :if-exists :rename-and-delete)))
	(format stream ";;; Automatically Generated Set Examples~% ;;; Author: Chris~% ;;; Number of Examples ~A~%" length)
	(omega~message "Writing examples to ~A" pathname)
	(dolist (ex writelist writelist)
	  (format stream "~%~A~%" ex))
	(format stream "~A" '(com~defcommand show-outlines (argnames) (argtypes) (arghelps) (frag-cats extern)
					     (function show-outlines) (log-p T)
					     (help "")))
	(format stream "~%~%~A~%" '(com~defcommand wait  (argnames seconds)  (argtypes
									      number)
						   (arghelps \"Seconds to wait.\")
						   (frag-cats extern)  (function sleep)
						   (defaults (5))  (Log-p T)   (help \"\")))
	(close stream))
      (let* ((pathname-new (pathname (concatenate 'string filename ".rpy")))
	     (stream-new (open pathname-new :direction :output
			       :if-exists :rename-and-delete)))
	(omega~message "Writing replay-file to ~A" pathname-new)
	(dolist (ex call-list call-list)
	  (format stream-new "~A~%" ex))
	(close stream-new)))
    length))


#+old(defun agplan=analyse-automatic-generated-set-examples (filename
							num-of-examples)
  (let ((pathname (pathname filename)))
    (load pathname)))

		  

(defun agplan~analyse-automatic-generated-set-examples
  (num-of-vars depth &optional (filename "/tmp/set-ex") (resultfile "/tmp/set-ex-out"))
  (let* ((list (agplan~generate-set-examples num-of-vars depth))
	 (pathname1 (pathname filename))
	 (pathname2 (pathname resultfile))
	 (stream (open pathname1 :direction :output :if-exists :rename-and-delete)))
    (format stream ";;; Automatically Generated Set Examples~% ;;; Author: Benzmueller\&Sorge~% ;;; Number of Examples ~A~%" (length list))
    (dolist (ex list nil)
	  (format stream "~A~%" ex))
    (close stream)
    (load pathname1)
    (omega~message "~%~% Automatically created ~A set equations:~%" (length list))
    (dolist (ex list list)
      (omega~message "~A" ex))))
    ;(sex~explore-testbed pathname1 pathname2)))
    
						     
(com~defcommand auto-analyse-set-examples
  (argnames num-of-vars depth example-file result-file)
  (argtypes number number pathname pathname)
  (arghelps "The number of variables." "The maximum construction depth." "Filename for the
example file." "Filename for the result-file")
  (frag-cats extern)
  (function agplan~analyse-automatic-generated-set-examples)
  (defaults (4 3 "/tmp/set-ex" "/tmp/set-ex-out"))
  (Log-p T) 
  (help ""))    
	

#| replaced by lea=extract-tolearn  MP						     
(defun agplan~pds2outline (&optional (pds pds*current-proof-plan))
  (labels ((agplan=recurse (node)
			   (when node
			     (let ((premises (pdsn~just-premises node)))
			       (cons (intern (string-upcase (string (agplan~name (pdsn~just-method node)))))
				     (when premises
				       (if (= (length premises) 1)
					   (agplan=recurse (car premises))
					 (mapcar #'agplan=recurse
						 premises))))))))
    (let* ((res (agplan=recurse (prob~proof-root pds)))
	   (string  (do* ((count 1 (incf count))
			  (comlist res (cdr comlist))
			  (com (agplan~find-corresponding-command (car comlist)) (agplan~find-corresponding-command (car comlist)))
			  (formatted-res (format nil "\"~A\"," com)
					 (concatenate 'string formatted-res (format nil "\"~A\"," com))))
			((>= count (- (length res) 1))
			 (format nil "[~A]"
				 (concatenate 'string formatted-res (format nil "\"~A\"" (agplan~find-corresponding-command (car (last comlist))))))))))
      (omega~message "OUTLINE of current PDS: ~A" string)
      (setq pds*outlines (if pds*outlines
			     (if (OHLP=FIND-SUBSTRING-LIST string (list pds*outlines))
				  pds*outlines  
			       (concatenate 'string pds*outlines  (format nil ",~A" string)))
			   (format nil "~A" string)))
      (omega~message "All outlines so far : [~A]" pds*outlines)
      (omega~message "Writing outlines so far to file ~A." (pathname "/tmp/set-ex-outlines"))
      (let ((stream (open (pathname "/tmp/set-ex-outlines") :direction :output
				    :if-exists :rename-and-delete)))
	(format stream "[~A]" pds*outlines)
	(close stream)))))

	    
				       
(com~defcommand pds2outline
  (argnames )
  (argtypes )
  (arghelps )
  (frag-cats extern)
  (function agplan~pds2outline)
  (defaults )
  (Log-p T) 
  (help "Shows the OUTLINE (in the sense of Mateja Learning project) of the
current pds."))
|#


(defun agplan=leo-partial-result-subnode-p (node)
  (when (keim~equal node (foci~focus-line (foci~active-pc)))
    (let ((first-desc (first (foci~descendants (foci~active-pc)))))
      (when (and first-desc (string-equal (keim~name (just~method (node~justification first-desc)))
					  'NOTE))
	(let ((first-prem (first (just~premises (node~justification first-desc)))))
	  (and first-prem (string-equal (keim~name (just~method (node~justification first-prem)))
					  'LEO-DERIVATION)))))))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Automatically exploring set examples
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defvar sex*explore-process nil)

(defun sex~explore-testbed (file outfile)
  (setf sex*explore-process
        (proc~create :name "Set Examples Exploration"
                     :function #'sex=run-function
                     :args (file outfile))))

(defun sex=run-function (file outfile)
  (let ((stream (open outfile :direction :output
		      :if-exists :rename-and-delete))
	(count*pos 0)
	(count*neg 0))
    (format stream "This file reports on the validity/invalidity of the examples defined
in ~A~% Authors: Benzmueller & Sorge ~%" file)
    (do ((result (keim::th=read-next-sexp file) (keim::th=read-next-sexp)))
	((null result) (print "Done exploring!"))
      (let* ((problem (eval result)))
	(print "hier")
	
	(opr~enqueue-command (opr~normalize-command 'prove
						    :args (list problem) :process
						    (proc~actual-process)))
	(opr~enqueue-command (opr~normalize-command 'automate :process (proc~actual-process)))
	(proc~sleep 8)
	(proc~wait "Waiting for automated proof search to finish!"
		   #'(lambda () (not (proc~is-active auto*process))))
	(format stream "~% ~A: ~A" (second result)
		(if (find-if #'(lambda (x) (string-equal (keim~name (just~method (pdsc~an-just x)))
							 "COUNTEREXAMPLE-BY-SATCHMO"))
			     (pds~plan-steps pds*current-proof-plan))
		    (progn (setf count*neg (1+ count*neg)) "COUNTEREXAMPLE")
		  (progn (setf count*pos (1+ count*pos)) "PROOF")))
	(omega~message "Removing files in ~A" (atptop~default-directory))
	))
    ;;;(sys~call-system (format nil "\\rm -rf ~A*" (atptop~default-directory)))))
    (format stream "~%~% Valid examples: ~A ~% Invalid examples: ~A ~% All examples: ~A" count*pos count*neg (+ count*pos count*neg))
    (omega~message "~%Result of case study written to file ~A ~% Valid examples: ~A ~% Invalid examples: ~A ~% All examples: ~A" outfile count*pos count*neg (+ count*pos count*neg))
    (close stream)))



(com~defcommand explore-set-examples
                (argnames file outfile)
                (argtypes pathname pathname)
                (arghelps "The pathname of the set examples" "The output pathname")
                (frag-cats extern)
                (function sex~explore-testbed)
		(defaults ("/tmp/set-ex" "/tmp/set-ex-out"))
                (log-p t)
                (help "Automatically explore a file with set examples."))     
