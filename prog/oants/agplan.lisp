(in-package :omega)


(mod~defmod AGPLAN 
            :uses (BLIK OMEGA OTTER atpprb atptop env f2p foci infer just keim logic node omega ot pds pl2p prob res2nd satch socket sugg sys term th type view)
            :documentation "The file provides functionality for agent based theorem proving with external systems."
            :exports (
		      agplan*current-counterexample
		      agplan~current-counterexample 
                      agplan~find-counterexample-by-satchmo
                      agplan~lookup-pds
                      agplan~pds-hashtable
                      agplan~show-orig-pds
                      agplan~show-pds
                      agplan~store-new-pds
                      agplan~tackle-by-fo-atp
                      agplan~tackle-by-leo
		      agplan~tackle-by-leo-pl
                      agplan~tackle-by-pl-atp
                      agplan~tackle-by-tps
		      agplan~copy-pds
		      agplan~matching-term
		      agplan~current-open-node
		      agplan~current-open-node
		      agplan~contained-definition
		      agplan~contained-definitions
		      agplan~negate
		      agplan~str-pos-subf-p
		      agplan~str-pos-subforms
		      agplan~repeated-line-p
		      agplan~define-variables
		      agplan~get-definition&pos
		      agplan~ext-check
		      agplan~pl-like-formula-p
		      ;agplan~pds2outline
		      agplan~simplify-goal-with-cas
		      agplan~simplify-with-cas
		      agplan~name
                      ))

;;; The following functions are internal in other modules and should not be used:
;;; (lc=default-tactic oc=call-leo-get-proof oc=default-auto-pds-names oc=expand-node tps=call-tps)


(defvar agplan*current-counterexample nil "The last counterexample that has been found")

(defun agplan~current-counterexample () agplan*current-counterexample)

(defun agplan~pds-hashtable ()
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "None.")
	   (effect  "None.")
	   (value   "The proofs hashtable for proofs automatically found in the background."))
  (foci~pds-hashtable (foci~active-pc)))

(defun agplan~store-new-pds (line prover additional-name pds) 
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "Proof line, name of the prover, additional-name-string, and the pds to store.")
	   (effect  "Modifies agplan*pds-hashtable.")
	   (value   "Inserts a new entry in the agplan*pds-hashtable. The key is line-name*prover*additional-name."))
  (let ((key (string-upcase (format nil "~A*~A*~A" (agplan~name line) prover additional-name))))
    (setf (gethash key (agplan~pds-hashtable)) pds)
    key))

(defun agplan~lookup-pds (name)
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "A string or a symbol.")
	   (effect  "None.")
	   (value   "The entry in the rule/tactic classifier hashtable associated with obj"))
  (if (stringp name) 
      (gethash  (string-upcase name) (agplan~pds-hashtable))
    (when (symbolp name) 
      (gethash (string-upcase (symbol-name name)) (agplan~pds-hashtable)))))


(defun agplan~pds-hashtable-indices ()
  (declare (edited  "22-Sep-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "None.")
	   (value   "All indices of the pds hashtable."))
  (let ((list nil))
    (maphash #'(lambda (x y) (declare (ignore y)) (push x list)) (agplan~pds-hashtable))
    list))


(defun agplan~pds-hashtable-entries ()
  (declare (edited  "22-Sep-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "None.")
	   (value   "All entries of the pds hashtable."))
    (let ((list nil))
      (maphash #'(lambda (x y) (declare (ignore x)) (push y list)) (agplan~pds-hashtable))
      list))


(defun agplan~advertised-proofs (line)
  (declare (edited  "22-Oct-2000")
	   (authors Chris)
	   (input   "A proof line")
	   (effect  "None.")
	   (value   "A list with the names of all (partial) proofs being advertised from external systems for this line."))
  (let ((prooflist (remove-if-not #'(lambda (x) (string< (agplan~name line) x))
				(agplan~pds-hashtable-indices))))
    (omega~message "~% The following is a list of proofs advertised for node ~A ~% ~A~%"
		   (agplan~name line)
		   prooflist)
    prooflist))
		 



(defun agplan~show-pds (name)
  (declare (edited  "09-Mar-2000")
	   (authors Chris)
	   (input   "A string or a symbol.")
	   (effect  "None.")
	   (value   "The entry in the rule/tactic classifier hashtable
associated with obj"))
    (let* ((node (pds~label2node name))
	   (res (if node (car (keim~get node 'atp-problems))
		  (agplan~lookup-pds name))))
      (cond ((atpprb~leo-problem-p res) ;;; this means it is a problem generated by leo
	     (progn
	       (view~clean-proof view*view)
	       (mapc #'(lambda (x) (socket~write x :inout))
		     (atpprb~leoloui-proof res))))
	    ((stringp res)             ;;; e.g. in case of a counterexample
	     (omega~trace res))
	    ((pds~proof-plan-p res)
               ;;; dirty hack
	     (let ((omega*current-proof-plan omega*current-proof-plan)
		   (keim::pds*current-proof-plan keim::pds*current-proof-plan))
	       (agplan=show res)
	       (pds~show-proof-plan res))))))


(defun agplan=show (proof-plan)
  (let ((omega*current-proof-plan proof-plan)
	(omega*current-theory (prob~proof-theory proof-plan))
	(logic*current-theory omega*current-theory)
	(keim::pds*current-proof-plan proof-plan))
    (when view*on 
      (view~unhide-proof omega*current-proof-plan)
      (view~clean-proof view*view)
      (view~display-proof omega*current-proof-plan))))



(defun agplan~show-orig-pds ()
  (agplan=show omega*current-proof-plan))


;;;; copied from atp-trans-conversation.lisp, as not exported yet

(defun agplan=new-problem-to-node (open-node pds)
  (declare (edited  "22-JUL-1999")
	   (authors Ameier)
	   (input   "An node to prove and the pds it occurs in.")
	   (effect  "None.")
	   (value   "A new problem, consisting of the open node as conclusion and its supports as assumptions."))
  
  (let* ((new-name (intern (string-upcase (format nil "~A-problem" (agplan~name open-node)))))
	 (pds-env (pds~environment pds))
	 (pds-problem (prob~proof-problem pds))
	 (pds-problem-env (prob~environment pds-problem))
	 (th-env (th~env (prob~theory pds)))
	 (new-env (env~create (list th-env)))
	 (new-conclusion (node~create (agplan~name open-node) (node~formula open-node) (just~create (infer~find-method 'open) nil)))
	 (new-assumptions (mapcar #'(lambda (supp)
				      (node~create (agplan~name supp) (node~formula supp) (just~create (infer~find-method 'hyp) nil)))
				  (remove open-node (pds~node-supports open-node))))
	 (new-problem (prob~create new-name (prob~theory pds) new-env new-assumptions new-conclusion))
	 (all-type-vars (append (env~class-keys pds-env 'type+variable nil)
				(env~class-keys pds-problem-env 'type+variable nil)))
	 (all-type-constants (append (env~class-keys pds-env 'type+constant nil)
				     (env~class-keys pds-problem-env 'type+constant nil)))
	 (all-constants (append (env~class-keys pds-env 'term+constant nil)
				(env~class-keys pds-problem-env 'term+constant nil)))
	 (all-variables (append (env~class-keys pds-env 'term+variable nil)
				(env~class-keys pds-problem-env 'term+variable nil))))

    (mapcar #'(lambda (key)
		(let* ((obj (env~lookup-object key pds-env)))

		  (env~enter key obj new-env)))
	    (append all-type-vars
		    all-type-constants
		    all-constants
		    all-variables))
    
    new-problem))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Different tackle by function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun agplan~tackle-by-pl-atp (line &optional agent-name (time-resource 10))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (atptop*interactivity-allowed nil)
	 (omega*current-resolution-proof nil))
    (OC=COMMAND-CALL-PL-ATP-ON-NODE new-line
				   (atptop~get-default-directory)
				   'AUTO
				   'PARSE
				   'T
				   ""
				   ""
				   time-resource
				   'COMPACT
				   NIL
				   NIL
				   2
				   'T
				   'T
				   'CONSTANTS)
    (when OMEGA*CURRENT-RESOLUTION-PROOF  ;;; means that otter has indeed found a proof (is this ok andreas)
      (agplan~store-new-pds new-line :otter (gensym) omega*current-proof-plan))))



;(defun agplan~tackle-by-pl-atp (line)
;  (let ((res-proof (OTTER~CALL-OTTER
;                                       line ; the proof line
;                                       OMEGA*CURRENT-PROOF-PLAN
;                                       (atptop~get-default-directory) ; the directory 
;                                       1000 ; ressource
;                                       'auto ; mode
;                                       't ; get output
;                                       't ; proof-object
;                                       (string "") ; user-flag-string
;                                       (string "") ; user-weight-string
;                                       :P2PL
;                                       'T)))
;    (when res-proof  ;;; dirty hack
;      (let ((new-pds (agplan~copy-pds omega*current-proof-plan))
;            (new-line (agplan~find-corresponding-open-line line new-pds))
;            (omega*current-proof-plan new-pds)
;            (keim::pds*current-proof-plan new-pds)
;            (foci*in-use nil))
;        (print "Transform Proof")
;        (res2nd~transform res-proof)
;        (f2p~translate omega*current-proof-plan)
;        (agplan~store-new-pds new-line :otter (gensym) new-pds)))))




(defun agplan~tackle-by-tps (line)
    (let* ((number-of-orig-proof-steps (length (prob~proof-steps
						omega*current-proof-plan)))
	   (new-pds (agplan~copy-pds))
	   (new-line (agplan~find-corresponding-open-line line new-pds))
	   ;; is the first in this list really the current open
	   ;; node, i.e. the copy of 'line'?
	   (omega*current-proof-plan new-pds)
	   (keim::pds*current-proof-plan new-pds)
	   (atptop*interactivity-allowed nil)
	   (foci*in-use nil))
      ; (sleep 1)  ;;; kann spaeter wieder weg
    (let ((res (tps=call-tps new-line 60 "MS98-HO-MODE" t nil nil)))
      (cond ((and (equal res :partial-proof)
		  (not (= number-of-orig-proof-steps
			  (length (prob~proof-steps omega*current-proof-plan)))))
	     (agplan~store-new-pds new-line :tps (gensym) new-pds))
	    ((equal res :complete-proof) ;;; complete proof
	      (let ((view*on nil))
		; (oc=expand-node new-line)
		)
	      (agplan~store-new-pds new-line :tps (gensym) new-pds))))))




(defun agplan~find-counterexample-by-satchmo (line)
  (multiple-value-bind (res out-string)
      (satch~call-satchmo line ; the proof line
			  OMEGA*CURRENT-PROOF-PLAN
			  (atptop~get-default-directory) ; the directory 
			  1000			; ressource
			  )
    (setf agplan*current-counterexample out-string)
    (let ((new-pds (when (not res)  ;;; if res is T there is NO countermodel
	       (format nil "~%Satchmo has found a countermodel for line ~A: ~%~A~%" line
		       (sex~print-model out-string)))))
      (when new-pds 
	(agplan~store-new-pds line :satchmo (gensym) new-pds)))))





(defun agplan~tackle-by-fo-atp (line &optional agent-name (time-resource 10))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (atptop*interactivity-allowed nil)
	 (omega*current-resolution-proof nil))
    (OC=COMMAND-CALL-OTTER-ON-NODE new-line
				   (atptop~get-default-directory)
				   'AUTO
				   'PARSE
				   'T
				   ""
				   ""
				   time-resource
				   'COMPACT
				   NIL
				   NIL
				   2
				   'T
				   'NIL
				   'CONSTANTS)
    (when OMEGA*CURRENT-RESOLUTION-PROOF  ;;; means that otter has indeed found a proof (is this ok andreas)
      (agplan~store-new-pds new-line :otter (gensym) omega*current-proof-plan))))



(defun agplan~tackle-by-leo (line &optional (tactic 'ext-input-recursive)  (time-bound 10))
    (let* ((new-pds (agplan~copy-pds))
	   (new-line (agplan~find-corresponding-open-line line new-pds))
	   ;; is the first in this list really the current open
	   ;; node, i.e. the copy of 'line'?
	   (omega*current-proof-plan new-pds)
	   (keim::pds*current-proof-plan new-pds)
	   (atptop*interactivity-allowed nil)
	   (foci*in-use nil))
      ; (sleep 1)  ;;; kann spaeter wieder weg
      (let ((res (oc=call-leo-on-node new-line tactic (leo~direct-supports  new-line) time-bound (list 'typed-set) (list '= 'defined 'equiv) t)))
	(cond ((eq res :leopartial)
	       (agplan~store-new-pds new-line :leopartial (gensym) omega*current-proof-plan))
	      ((eq res :leo)
	       (agplan~store-new-pds new-line :leo (gensym) omega*current-proof-plan))))))

(defun agplan~tackle-by-leo-pl (line &optional (tactic 'ext-input-recursive)  (time-bound 0))
    (let* ((new-pds (agplan~copy-pds))
	   (new-line (agplan~find-corresponding-open-line line new-pds))
	   ;; is the first in this list really the current open
	   ;; node, i.e. the copy of 'line'?
	   (omega*current-proof-plan new-pds)
	   (keim::pds*current-proof-plan new-pds)
	   (atptop*interactivity-allowed nil)
	   (foci*in-use nil))
      ; (sleep 1)  ;;; kann spaeter wieder weg
      (let ((res (oc=call-leo-on-node new-line tactic (leo~direct-supports  new-line) time-bound nil nil t)))
	(cond ((eq res :leopartial)
	       nil)
	      ((eq res :leo)
	       (agplan~store-new-pds new-line :leo (gensym) omega*current-proof-plan)
	       ; omega*current-proof-plan
	       )))))      

(defun agplan~find-corresponding-open-line (open-line pds)
  (let ((all-open-lines (pds~open-nodes pds)))
    (find-if #'(lambda (x) (equal (intern (agplan~name open-line)) (intern (agplan~name x))))
	  all-open-lines)))

(defun agplan~copy-pds (&optional pds*current-proof-plan)
  (let ((path (pathname (format nil "/tmp/~A" (gensym "pds")))))
    (oc=write-pds path t)
    (let ((pname (pathname (format nil "~A.pds" path))))
      (sys~handler-case
       (with-open-file (in pname :direction :input
			   :if-does-not-exist :error)
		       (let* ((list (read in))
			      (newobj (post~read-object (append (list (car list) nil) (cdr list))
							(env~create)
							nil))
			      (new-plan (ot~read-proof-plan newobj)))
			 (delete-file pname)
			 new-plan))
       (file-error (c) (inter~print-error (comint~interface
					   comint*current-comint) c))))))
       


(defun agplan~apply-advertised-pds (name)
  (let ((pds (agplan~lookup-pds name)))
    (when pds
      (foci~compute-pcs :pds pds)
      (oc=prove pds)
      (sugg~reset)
      )))

(defun agplan~best-advertised-proof ()
  (car (agplan~best-advertised-proofs)))
 
(defun agplan~best-advertised-proofs ()
  (sort (agplan~advertised-proofs (car (pds~open-nodes omega*current-proof-plan)))
	#'agplan~proof-priorisation-heuristics  ;;; bis jetzt gucke ich nur auf Namen; LEO wird priorisiert
	))

(defun agplan~proof-priorisation-heuristics (x y)
  (declare (ignore y))
  (string< (format nil "~A*~A" (agplan~name (car (pds~open-nodes omega*current-proof-plan))) :LEO) x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; additional stuff ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun agplan~matching-term (term1 term2)
  (declare (edited  "07-DEC-2000")
	   (authors Achim)
	   (input   "Two terms.")
	   (effect  "None.")
	   (value   "If the terms match in exactly one sub-term, the codomain of the corresponding"
		    "matching substitution. O/w NIL."))
  (let ((subst (term~alpha-match term1 term2)))
    (when (and subst (= 1 (length (subst~domain subst))))
      (car (subst~codomain subst)))))


(defun agplan~current-open-node ()
   (foci~focus-line (foci~active-pc))) 


(defun agplan~current-proof-plan ()
  keim::pds*current-proof-plan
  )

(defun agplan~contained-definition (formula)
  (declare (edited  "17-APR-1998")
           (authors Chris)
           (input   "A formula")
           (effect  "None")
           (value   "The first definition within term"))
 (car (agplan~contained-definitions formula)))


(defun agplan~contained-definitions (formula)
  (declare (edited  "17-APR-1998")
           (authors Chris)
           (input   "A formula")
           (effect  "None")
           (value   "The definitions within term"))
  (let* ((poslist (data~positions formula #'(lambda (x) (and (term~constant-p x)
							     (th~find-assumption
							      (agplan~name x)
							      (prob~theory omega*current-proof-plan))))))
         (constants
	  (remove-if
	   #'(lambda (x) (or (keim~equal "FORALL-SORT" (agplan~name x))
			     (keim~equal "EXISTS-SORT" (agplan~name x))
			     (keim~equal "EQUIV" (agplan~name x))
			     ;;;(keim~equal "STRUCT-UNIT" (agplan~name x))
			     (keim~equal "=" (agplan~name x))))
	   (remove-duplicates
	    (mapcar #'(lambda (pos) (data~struct-at-position formula pos))
		    poslist) :test #'keim~equal)))
	 (defs (mapcar #'(lambda (x)
			   (th~find-assumption (agplan~name x)
					       (prob~theory omega*current-proof-plan)))
		       constants)))
    defs))


(defun agplan~negate (formula)
  (when (term~p formula)
    (term~appl-create (logic~negation-constant) (list formula))))



(defgeneric agplan~str-pos-subf-p (obj1 obj2 &optional bindables extract-info)
  (declare (edited  "28-12-99")
	   (authors Chris)
	   (input   "Two objects, where obj1 is a node or a formula and obj2 a"
		    "node, formula or a list nodes or formulas. (Furthermore, Optionally a list of"
		    "bindable variables and an extraction information.")
	   (effect  "None.")
	   (value   "A list containing list of:"
		    "precise extraction information (list of command names (+ additional info)"
		    "and a node"))
  (:method ((obj1 node+node) obj2 &optional bindables extract-info)
	   (agplan~str-pos-subf-p (node~formula obj1) obj2 bindables extract-info))
  (:method (obj1 (obj2 list) &optional bindables extract-info)
	   (mapcan #'(lambda (x) (agplan~str-pos-subf-p obj1 x bindables extract-info))
		   obj2))
  (:method (obj1 (obj2 node+node) &optional bindables extract-info)
	   (agplan~str-pos-subf-p obj1 (node~formula obj2) bindables (cons (agplan~name obj2) extract-info)))
  (:method ((obj1 term+term) (obj2 term+term) &optional bindables extract-info)
	   (let ((res-weaken (let ((subst (term~alpha-unify obj2 obj1)))
			       (when subst
				 ;(not (set-difference (subst~domain subst) bindables
				 ;      :test #'data~equal)))
				 (list (cons (list :WEAKEN subst) extract-info)))))
		 (res-conj (when (logic~conjunction-p obj2) ; A <= (A and B); A <= (B and
							    ; A)
			     (append
			      (agplan~str-pos-subf-p obj1
						  (first (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-AND-E-l extract-info))
			      (agplan~str-pos-subf-p obj1
						  (second (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-AND-E-r extract-info)))))
		 (res-disj (when (logic~disjunction-p obj2) ; A <= (A or B); A <= (B or A)
			     ;; extend this part by introducing all possible formulas C
			     (append 
			      (agplan~str-pos-subf-p obj1
						  (first (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-OR-E-l extract-info))
			      (agplan~str-pos-subf-p obj1
						  (second (data~appl-arguments obj2))
						  bindables
						  (cons :NIC-OR-E-r extract-info)))))
		 (res-imp (when (logic~implication-p obj2) ; A <= (B implies A)
			    ;; extend this by introducing all possible formulas A
			    (append 
			     (agplan~str-pos-subf-p obj1
						 (second (data~appl-arguments obj2))
						 bindables
						 (cons :NIC-IMP-E extract-info)))))
		 (res-all (when (logic~universal-quantification-p obj2) ; A(t) <= ALL x . A(x) for every
					                                ; term t
			    (let ((bound-var (logic~quantification-bound-variable obj2)))
			      (agplan~str-pos-subf-p obj1
						  (logic~quantification-scope obj2)
						  (cons bound-var bindables)
						  (cons (list :NIC-FORALL-E bound-var)
							(cons (LIST :DECLARE `(variables
									       (,bound-var
										,(data~annotation bound-var)
										)))
							      extract-info))))))
		 (res-ex (when (logic~existential-quantification-p obj2) ; A(t) <= EX x . A(x) for
				                                         ;  every term t

			   ;; How to handle skolemization
			   (multiple-value-bind (new-obj2 skolemterms)
			       (hocnf~skolemize (logic~quantification-scope obj2)
						(list (logic~quantification-bound-variable obj2))
						(foci~free-vars (foci~active-pc))
						(pds~environment omega*current-proof-plan))
			     (agplan~str-pos-subf-p obj1 new-obj2 bindables
						 (cons (list :NIC-EXISTS-E-e (car skolemterms)) extract-info))))))
	     (append res-weaken res-conj res-disj res-imp res-all res-ex))))



(defgeneric agplan~str-pos-subforms (obj1)
  (declare (edited  "28-12-99")
	   (authors Chris)
	   (input   "An objects, which is a list, node or a formula")
	   (effect  "None.")
	   (value   "A list containing of strictly positive subformulas of obj1"))
  (:method ((obj1 list))
	   (remove-duplicates (mapcan #'agplan~str-pos-subforms obj1) :test #'keim~equal))
  (:method ((obj1 node+node))
	   (agplan~str-pos-subforms (node~formula obj1)))
  (:method ((obj1 term+term))
	   (cond ((logic~atom-p obj1) (list obj1))
		 ((logic~negation-p obj1) (list obj1))
		 ((logic~conjunction-p obj1) ; A <= (A and B); A <= (B and
					; A)
		  (cons obj1
			(append
			 (agplan~str-pos-subforms (first (data~appl-arguments obj1)))
			 (agplan~str-pos-subforms (second (data~appl-arguments obj1))))))
		 ((logic~disjunction-p obj1) ; A <= (A or B); A <= (B or A)
		  ;; extend this part by introducing all possible formulas C
		  (cons obj1
			(append 
			 (agplan~str-pos-subforms (first (data~appl-arguments obj1)))
			 (agplan~str-pos-subforms (second (data~appl-arguments obj1))))))
		 ((logic~implication-p obj1) ; A <= (B implies A)
		  ;; extend this by introducing all possible formulas A
		  (cons obj1
			(agplan~str-pos-subforms (second (data~appl-arguments obj1)))))
		 ((logic~universal-quantification-p obj1) ; A(t) <= ALL x . A(x) for every
					; term t
		  (cons obj1
			(agplan~str-pos-subforms (logic~quantification-scope obj1))))
		 ((logic~existential-quantification-p obj1) ; A(t) <= EX x . A(x) for
					;  every term t
		  (cons obj1
			(agplan~str-pos-subforms (hocnf~skolemize (logic~quantification-scope obj1)
							       (list (logic~quantification-bound-variable obj1))
							       (foci~free-vars (foci~active-pc))
							       (pds~environment
								omega*current-proof-plan))))))))



(defgeneric agplan~repeated-line-p (obj)
  (declare (edited  "29-12-99")
           (authors Chris)
           (input   "A proof line or a formula.")
           (effect  "None.")
           (value   "T, iff line is a repeated proof line or formula in proof search."))
  (:method ((obj node+node))
	   (some #'(lambda (x)
		      (and (term~alpha-equal (node~formula x) (node~formula obj))
			   ; (subsetp (pdsn~hyps obj) (pdsn~hyps x))
			   (or (not (nic~elimination-p x)) (nic~elimination-p obj))))
		  (let ((descendants (foci~descendants (foci~active-pc)))
			(supports (pds~node-supports (foci~focus-line (foci~active-pc)))))
		   (append (when descendants (rest descendants)) supports)))) ;;; the first descendant may
							    ;;; be identical to the
							    ;;; current goal, see or-e
  (:method ((obj term+term))
	   (some #'(lambda (x) (term~alpha-equal (node~formula x) obj))
		 (let ((descendants (foci~descendants (foci~active-pc)))
		       (supports (pds~node-supports (foci~focus-line (foci~active-pc)))))
		   (append (when descendants (rest descendants)) supports)))))
                                                             ;;; the first descendant may
							     ;;; be identical to the
							     ;;; current goal, see or-e

(defun agplan~define-variables (term)
  (declare (edited  "10-MAY-2000")
	   (authors Ceb)
	   (input   "A term")
	   (effect  "Declares the free variables of term in the environment")
	   (value   "Undefined"))
  (let* ((variables (term~free-variables term))
	 (form (mapcar #'(lambda  (x) (list x (data~annotation x)))
		       variables)))
    (post~read-object (cons 'variables form)
		      (pds~environment omega*current-proof-plan) nil)))
  

(defun agplan~get-definition&pos (line)
  (let ((definition (agplan~contained-definition line)))
    (values
     definition
     (let* ((definition (th~definition-constant definition))
	    (definition (if (data~schema-p definition)
			    (data~schema-range definition)
			  definition)))
       (car
	(data~substruct-positions 
	 definition
	 line))))))


(defun agplan~ext-check (all-term eq-term)
  (when (and (logic~equality-p eq-term)
	     (logic~universal-quantification-p all-term))
    (let* ((left (car (data~appl-arguments eq-term)))
	   (right (cadr (data~appl-arguments eq-term)))
	   (eq (data~appl-function eq-term))
	   (bound (logic~quantification-bound-variable all-term))
	   (scope (logic~quantification-scope all-term))
	   (new-left (data~appl-create left (list bound)))
	   (new-right (data~appl-create right (list bound))))
      (and (logic~equality-p scope)
	   (data~equal (car (data~appl-arguments scope)) new-left)
	   (data~equal (cadr (data~appl-arguments scope)) new-right)))))


(defmethod bb~command-suggestion-leq-p
  ((sugg1 bb+command-suggestion) (sugg2 bb+command-suggestion) (indicator (eql :i-e-f-demo-old)))
  (let ((com1 (mapcar #'agplan~name (com~categories (bb~entry-command sugg1))))
	(com2 (mapcar #'agplan~name (com~categories (bb~entry-command sugg2)))))
    (flet ((in (cat list)
	       (find cat list :test #'string-equal)))
      (or (in :extern com2)
	  (and (in :nic-special-tactic com2) (not (in :extern com1)))
	  (and (and (in :that com2) (in :elimination com2))
	       (not (in :extern com1))
	       (not (in :nic-special-tactic com1)))
	  (and (in :quantifier com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1))
	       (not (and (in :that com1) (in :elimination com1))))
	  (and (in :definition com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (and (in :that com1) (in :elimination com1))))
	  (and (in :elimination com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1))
	       (not (and (in :that com1) (in :elimination com1))))
	  (and (and (in :introduction com2) (not (in :that com2)))
	       (not (in :extern com1)) 
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)) (not (in :elimination com1))
	       (not (and (in :that com1) (in :elimination com1))))
	  (and (and (in :that com2) (in :introduction com2))
	       (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)) (not (in :elimination com1))
	       (not (and (in :introduction com1) (not (in :that com1))))
	       (not (and (in :that com1) (in :elimination com1))))
	  (and (in :false com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :elimination com1)) (not (in :definition com1))
	       (not (and (in :introduction com1) (not (in :that com1))))
	       (not (and (in :that com1) (in :elimination com1))))))))


(defmethod bb~command-suggestion-leq-p
  ((sugg1 bb+command-suggestion) (sugg2 bb+command-suggestion) (indicator (eql :i-e-f-demo)))
  (let ((com1 (mapcar #'agplan~name (com~categories (bb~entry-command sugg1))))
	(com2 (mapcar #'agplan~name (com~categories (bb~entry-command sugg2)))))
    (flet ((in (cat list)
	       (find cat list :test #'string-equal)))
      (or (in :extern com2)
	  (and (in :nic-special-tactic com2) (not (in :extern com1)))
	  (and (in :quantifier com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)))
	  (and (in :definition com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1)))
	  (and (and (in :elimination com2) (not (in :that com2)))
	       (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)))
	  (and (and (in :introduction com2) (not (in :that com2)))
	       (not (in :extern com1)) 
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1))
	       (not (and (in :elimination com1) (not (in :that com1)))))
	  (and (and (in :that com2) (in :elimination com2))
	       (not (in :extern com1)) (not (in :nic-special-tactic com1))
	       (not (in :quantifier com1)) (not (in :definition com1))
	       (not (and (in :elimination com1) (not (in :that com1))))
	       (not (and (in :introduction com1) (not (in :that com1)))))
	  (and (and (in :that com2) (in :introduction com2))
	       (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :definition com1)) (not (in :elimination com1))
	       (not (and (in :introduction com1) (not (in :that com1)))))
	  (and (in :false com2) (not (in :extern com1))
	       (not (in :nic-special-tactic com1)) (not (in :quantifier com1))
	       (not (in :elimination com1)) (not (in :definition com1))
	       (not (in :introduction com1)) (not (in :that)))))))

(defun agplan~pl-like-formula-p (formula)
  (let ((substructs (data~all-substructs formula)))
    (not (find-if #'(lambda (x) (or (term~variable-p x) (logic~equality-p x)
				    (when (and (term~constant-p x)
				               (not (keim~equal (logic~equivalence-constant) x)))
					  (th~find-assumption (agplan~name x)
							      (prob~theory omega*current-proof-plan)))))
		  substructs))))


(defvar pds*outlines nil)

(defvar agplan*justification-command-hashtable (make-hash-table :test #'equal)
  "Hash table, indexed by justification name, that holds names of corresponding rules/tactics.")

(defun agplan~justification-command-hashtable ()
  (declare (edited  "06-JAN-2000")
	   (authors Chris)
	   (input   "None.")
	   (effect  "None.")
	   (value   "The justofication command hashtable."))
  agplan*justification-command-hashtable)

(defun agplan~set-up-justification-command-hashtable ()
  (declare (edited  "06-JAN-2000")
	   (authors Chris)
	   (input   "None")
	   (effect  "Sets up the justification-command-hashtable.")
	   (value   "The  justification-command-hashtable."))
  (setf (gethash (string-upcase "NIC-FORALL-I") (agplan~justification-command-hashtable)) "NICTAC-FORALL-I")
  (setf (gethash (string-upcase "PL-ATP") (agplan~justification-command-hashtable)) "CALL-PL-ATP-ON-NODE")
  (setf (gethash (string-upcase "COUNTEREXAMPLE-WITH-SATCHMO") (agplan~justification-command-hashtable)) "CALL-SATCHMO-ON-NODE")
  (agplan~justification-command-hashtable))

(agplan~set-up-justification-command-hashtable)

(defun agplan~find-corresponding-command (com)
  (let* ((com-name (if (stringp com) (string-upcase com) (string-upcase (format nil "~A" com))))
	 (res (gethash  (string-upcase com-name) (agplan~justification-command-hashtable))))
    (if res res com-name)))



(defun agplan~simplify-goal-with-cas (line &optional (pds PDS*CURRENT-PROOF-PLAN))
  (let* ((new-pds (agplan~copy-pds omega*current-proof-plan))
	 (omega*current-proof-plan new-pds)
	 (keim::pds*current-proof-plan new-pds)
	 (foci*in-use nil)
	 (new-line (agplan~find-corresponding-open-line line new-pds))
	 (new-hyps (leo~direct-supports new-line))
	 (simpl-new-hyps
	  (mapcar #'(lambda (x) (first (infer~compute-outline 'simplify-with-cas (list nil x)
						       nil)))
		  new-hyps))
	 (simpl-new-line
	  (second (infer~compute-outline 'simplify-with-cas (list new-line nil)
					 nil))))
    (when (or simpl-new-line
	      (find-if #'(lambda (x) (not (nullp x))) simpl-new-hyps))
      (agplan~store-new-pds new-line :simplify (gensym) omega*current-proof-plan))))
  
    


(defun agplan~simplify-with-cas (obj &optional (typelist (list 'num 'o))
				     (vars nil)
				     (env (pds~environment PDS*CURRENT-PROOF-PLAN)))
  (declare (edited  "28-11-00")
           (authors Chris)
           (input   "A formula; optionally a typelist (those two ehich the
CAS might be applied), list of bound vars, and an environment.")
           (effect  "None.")
           (value   "The simplified formula"))
  (let ((type (data~annotation obj)))
    (if (and (find (format nil "~A" type) typelist :test #'string-equal)
	     (not (data~positions obj #'(lambda (x)
					  (or (term~abstr-p x)
					      (and (term~variable-p x)
						   (find x vars)))))))
	(let* ((back (casex~compute-with-maple "simplify" obj))
	       ;;; use (rcl~call-maple (list "simplify" obj) :syntax 'post2post)
	       ;;; see volkers file restclass.lisp
	       (res  (when back (post~read-object back env :existing-term))))
	  (if (or (null res)
		  (and (stringp res) (string-equal res "error")))
	      obj
	    res))
      (cond ((term~appl-p obj)
	     (term~appl-create
	      (agplan~simplify-with-cas (data~appl-function obj) typelist vars env)
	      (mapcar #'(lambda (x) (agplan~simplify-with-cas x typelist vars env))
		      (data~appl-arguments obj))))
	    ((term~abstr-p obj)
	     (term~abstr-create
	      (data~abstr-domain obj)
	      (agplan~simplify-with-cas
	       (data~abstr-range obj) typelist
	       (append (data~abstr-domain obj) vars) env)))
	    ((term~primitive-p obj) obj)))))


(defgeneric agplan~name (obj)   ;;; introduced because agplan~name liefert bei numerals
			   ;;; numbers zuerueck, Bsp. (keim~name 20) --> number
			   ;;; 20
  (:method (obj)
	   (format nil "~A" (keim~name obj)))
  (:method ((schema data+schema))
	   (keim~name (data~schema-range schema))))


(defun agplan~contains-simplifiable-terms (node &optional (stringlist (list 'plus 'power
									    'times 'minus
									    'gcd 'lcm)))
  (data~positions node
		  #'(lambda (x) (and
				 (term~primitive-p x)
				 (find x stringlist
				       :test #'(lambda (x y)
						 (string-equal
						  (agplan~name x) y)))))))

(defgeneric agplan~contains-higher-concepts (node theory &rest defs)
  (declare (edited  "25-JAN-2001")
	   (authors Sorge)
	   (input   "A node and a symbol.")
	   (effect  "None.")
	   (value   "A list of positions of the node's formula where concepts from the given theory occur."))
  (:method (node (theory list) &rest defs)
	   (let ((theories (remove-if #'null (mapcar #'th~find-theory theory))))
	     (when theories
	       (let ((th-terms (mapcar #'keim~name (mapcan #'th~definitions theories)))
		     (add-defs (mapcar #'(lambda (x)
					   (agplan~name (env~lookup-object x (pds~environment omega*current-proof-plan)))) defs)))
	       (data~positions node
			       #'(lambda (x)
				   (and (term~primitive-p x)
					(find (agplan~name x) (append th-terms add-defs) :test #'string-equal))))))))
  (:method (node theory &rest defs)
	   (when (th~find-theory theory)
	     (let ((th-terms (mapcar #'keim~name (th~definitions (th~find-theory theory))))
		   (add-defs (mapcar #'(lambda (x)
					 (agplan~name (env~lookup-object x (pds~environment omega*current-proof-plan)))) defs)))
	       (data~positions node
			       #'(lambda (x)
				   (and (term~primitive-p x)
					(find (agplan~name x) (append th-terms add-defs) :test #'string-equal))))))))

(defun agplan~leo-partial-result-subnode-p (node)
  (when (keim~equal node (foci~focus-line (foci~active-pc)))
    (let ((first-desc (first (foci~descendants (foci~active-pc)))))
      (when (and first-desc (string-equal (keim~name (just~method (node~justification first-desc)))
					  'NOTE))
	(let ((first-prem (first (just~premises (node~justification first-desc)))))
	  (and first-prem (string-equal (keim~name (just~method (node~justification first-prem)))
					  'LEO-DERIVATION)))))))

