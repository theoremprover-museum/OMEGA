;;; -*- syntax: common-lisp; package: OMEGA; base: 10; mode: KEIM -*-
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
;;                                                                          ;;
;;   Copyright (C) 1996 by AG Siekmann, Fachbereich Informatik,             ;;
;;   Universitaet des Saarlandes, Saarbruecken, Germany.                    ;;
;;   All rights reserved.                                                   ;;
;;   For information about this program, write to:                          ;;
;;     OMEGA Project                                                        ;;
;;     AG Siekmann/FB Informatik                                            ;;
;;     Universitaet des Saarlandes                                          ;;
;;     Bau 36, 4. Stock                                                     ;;
;;     D-66041 Saarbruecken                                                 ;;
;;     Germany                                                              ;;
;;   electronic mail: keim@cs.uni-sb.de                                     ;;
;;                                                                          ;;
;;   The author makes no representations about the suitability of this      ;;
;;   software for any purpose.  It is provided "AS IS" without express or   ;;
;;   implied warranty.  In particular, it must be understood that this      ;;
;;   software is an experimental version, and is not suitable for use in    ;;
;;   any safety-critical application, and the author denies a license for   ;;
;;   such use.                                                              ;;
;;                                                                          ;;
;;   You may use, copy, modify and distribute this software for any         ;;
;;   noncommercial and non-safety-critical purpose.  Use of this software   ;;
;;   in a commercial product is not included under this license.  You must  ;;
;;   maintain this copyright statement in all copies of this software that  ;;
;;   you modify or distribute.                                              ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;

(in-package "OMEGA")

;; Noch verbesserungwuerdig:
;;
;; Am Zeilenumbruch in Formeln kann man noch basteln (tatsaechliche Zeichen zaehlen etc.
;; Sonderzeichen muessen wirkungsvoller abgefangen werden (*, +, etc.)
;; Zahlen und Sonderzeichen in der Mitte eines Termes ????
;; --> Sonderzeichen in mboxes....
;; Indizes oben ist ein Problem (wo sonst?)

(mod~defmod post2tex
	    :uses (omega) 
	    :documentation "Module defining functions for the tex output of (partial) proof plans."
	    :exports (
		      post2tex~write-ho-proof-to-file ;;nd-proof/plan-state file-name
		      post2tex~set-predefined-symbols ;;file-name
		      post2tex~reset-predefined-symbols
		      post2tex~sorted-structure  ;;nd-proof/plan-state
		      post2tex~rule-2-tex  ;; rule-name
		      post2tex~keim-name
		      ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Lots of Global Variable Definitions... 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Predefined Logical Symbols
(defvar post2tex*and "\\posttotexand")
(defvar post2tex*or "\\posttotexor")
(defvar post2tex*implies "\\posttoteximplies")
(defvar post2tex*equiv "\\posttotexequiv")
(defvar post2tex*not "\\posttotexnot")
(defvar post2tex*forall "\\posttotexforall")
(defvar post2tex*exists "\\posttotexexists")
(defvar post2tex*kappa  "\\posttotexkappa")

;;; Predefined TeX Stuff
(defvar post2tex*documentclass "\\documentclass[10pt]{article}")
(defvar post2tex*usepackage "\\usepackage{longtable}\\usepackage{amsfonts}")
(defvar post2tex*dina4 "\\oddsidemargin 6pt\\evensidemargin 6pt\\marginparwidth 48pt\\marginparsep 10pt 
\\topmargin -18pt\\headheight 12pt\\headsep 25pt\\footskip 30pt 
\\textheight 625pt\\textwidth 431pt\\columnsep 10pt\\columnseprule 0pt")
(defvar post2tex*include-macros (concatenate 'string
					     "\\input{" (*user-top-dir*) "omega-3/prog/post2tex/ndmacros}"))
(defvar post2tex*documentbegin "\\begin{document}")
(defvar post2tex*documentend "\\end{document}") 
(defvar post2tex*tabend "\\end{longtable}\\end{footnotesize}")
(defvar post2tex*tabbegin (format nil "\\setlongtables\\begin{footnotesize}\\begin{longtable}{p{2cm}p{3cm}@{$\\,\\vdash\\,$}p{9cm}l}"))

;;; Additional Stuff...
(defvar post2tex*predefined-file nil "The File where the predefined commands for the symbols can be found.")
(defvar post2tex*proof-name "ND-Proof")

(defvar post2tex*string-counter 70 "The maximum number of characters in line for a formula.")
(defvar post2tex*actual-string-counter 0 "The actual number of character.")

(defvar post2tex*brackets t "If t, set brackets around the connectives.")
(defvar post2tex*left-bracket "[")
(defvar post2tex*right-bracket "]")
(defvar post2tex*newline-symbol "\\newline ")

(defvar post2tex*environment nil "In this variable the symbols and their instances are related.")
;;;(defvar post2tex*type-output t "Flag indicating whether types should be printed.")
(defvar post2tex*types nil "In this variable the types are being stored.")
(defvar post2tex*typed-symbols nil
  "In this variable the objects are stored whose types have already been printed.")

(defvar post2tex*hyps-list nil "An A-List for storing hypotheses longer than 5 elements.")
(defvar post2tex*hyp-counter 0)
(defconstant post2tex*max-hyp-length 2)  ;;; A constant indicating the maximum number of elements in the hyplist.

(defvar post2tex*alpha-chars '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O
			       #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z #\a #\b #\c #\d
			       #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t
			       #\u #\v #\w #\x #\y #\z))
			       

(defclass post2tex+fo-infix-style (keim+object)
  ()
  (:documentation "This class is for printing objects in first order infix style"))

(defclass post2tex+ho-infix-style (keim+object)
  ()
  (:documentation "This class is for printing objects in higher order infix style"))

(defclass post2tex+plan-style (keim+object)
  ()
  (:documentation "This class is for printing objects in plan style"))


(defun post2tex~fo-infix-style ()
  (make-instance 'post2tex+fo-infix-style))

(defun post2tex~ho-infix-style ()
  (make-instance 'post2tex+ho-infix-style))

(defun post2tex~plan-style ()
  (make-instance 'post2tex+plan-style))

(defun post2tex~print-object (object style stream)
  (declare (edited  "19-AUG-1994 16:24")
	   (authors ACSEHN)
	   (input "A POST object, OBJECT, a STYLE and a STREAM."  )
	   (effect "The OBJECT is written in LaTeX on STREAM." )
	   (value "Undefined." )
	   (example "The style should be post2tex~fo-infix-style.")
	   )
  (post2tex=print-object object nil style stream))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; First Order Style Proof Printing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod post2tex=print-object ((object term+variable) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((objectname (post2tex=replace-special-chars (keim~name object))))
    (multiple-value-bind (name number) (post2tex=split-name objectname)
      (if (> (length name) 1)
	  (progn
	    ;(when (not (assoc object post2tex*environment :test #'keim~equal))
	    ;  (post2tex=insert-constant object 0))
	    (format stream "\\ptot~A" (string-upcase name))
	    (when (not (equal number ""))
	      (format stream "_{~A}" number)))
	(progn (format stream "~A" 
		       (if (keim~equal (type~o) (data~n-range (term~type object)))
			   (string-upcase name)
			 (string-downcase name)))
	       (when (not (equal number ""))
		 (format stream "_{~A}" number)))))))

(defmethod post2tex=print-object ((object term+constant) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((objectname (post2tex=replace-special-chars (keim~name object))))
    (multiple-value-bind (name number) (post2tex=split-name objectname)
      (if (> (length name) 1)
	  (progn
	    (when (not (assoc object post2tex*environment :test #'keim~equal))
	      (post2tex=insert-constant object 0 nil))
	    (format stream "\\ptot~A" (string-upcase name))
	    (when (not (equal number ""))
	      (format stream "_{~A}" number)))
	(progn ;(format T "~%num:~S" number)
	       (format stream "~A" 
		       (if (keim~equal (type~o) (data~n-range (term~type object)))
			   (string-upcase name)
			 (string-downcase name)))
	       (when (not (equal number ""))
		 (format stream "_{~A}" number)))))))

(defmethod post2tex=print-object ((object term+number) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((number (keim~name object)))
    (if (complexp number) (format stream "(~A+~Ai)" (realpart number) (imagpart number))
      (format stream "~A" number)
      )))

(defmethod post2tex=print-object ((object term+abstr) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists)
	   (ignore last-quantor))
  (write-string "\\lambda " stream)
  (post2tex=print-object (data~abstr-bound-var object) nil style stream)
  (write-string "\\lambdot" stream)
  (post2tex=print-object (data~abstr-scope object) nil style stream))



(defmethod post2tex=print-object ((object term+appl) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*brackets post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (cond ((and last-quantor
	      (or (logic~universal-quantor-p last-quantor)
		  (logic~existential-quantor-p last-quantor))
	      (not (logic~fo-quantification-p object))
	      )
					;(format T "~%last-q.:~A" last-quantor)
	 (write-string "\\lambdot" stream)
	 (post2tex=print-object object nil style stream))
	((logic~equality-p object)
	 (let ((args (data~appl-arguments object)))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (write-string "=" stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)))
	((logic~disjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string " (" stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*or stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string ") " stream))))
	((logic~implication-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string " (" stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*implies stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string ") " stream))))
	((logic~conjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string " (" stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*and stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string ") " stream))))
	((logic~equivalence-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string " (" stream))
	   (post2tex=print-object (first args) nil style stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (write-string post2tex*equiv stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string ") " stream))))
	((logic~negation-p object)
	 (let ((args (data~appl-arguments object)))
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*not stream)
	   (when post2tex*brackets
	     (write-string " (" stream))
	   (write-string " " stream)
	   (post2tex=print-object (first args) nil style stream)
	   (when post2tex*brackets
	     (write-string " ) " stream))
	   ))
	((logic~fo-quantification-p object)
	 (let ((quantif-var (logic~fo-quantification-bound-variable object))
	       (scope (logic~fo-quantification-scope object))
	       (new-quantor (data~appl-function object))
					;(head (data~appl-function object))
	       )
	   (if (or (not last-quantor)
		   (not (keim~equal (term~type new-quantor) (term~type last-quantor))))
	       (progn (cond ((logic~universal-quantification-p object)
			     (write-string " " stream)
			     (write-string post2tex*forall stream)
			     (write-string " " stream)
			     )
			    ((logic~existential-quantification-p object)
			     (write-string " " stream)
			     (write-string post2tex*exists stream)
			     (write-string " " stream)
			     ))
					;(write-string " " stream)
		      (post2tex=print-object quantif-var last-quantor style stream)
					;(write-string " " stream)
		      (post2tex=print-object scope new-quantor style stream))
	     (progn (write-string "," stream)
		    (post2tex=print-object quantif-var last-quantor style stream)
					;(write-string " " stream)
		    (post2tex=print-object scope new-quantor style stream)))
	   ))
	(t
	 (let ((head (data~appl-function object))
	       (rest (data~appl-arguments object)))
	   (multiple-value-bind (head-name head-number)
	       (post2tex=split-name (keim~name head))
	     (declare (ignore head-number))
	     (if (not (eq (length head-name) 1))
		 (progn
		   (post2tex=insert-constant head (length rest) nil)
		   (post2tex=print-object head nil style stream)
		   (write-string (post2tex=number2alpha (length rest)) stream)
		   (write-string "{" stream)
		   (dolist (elem (butlast rest))
		     (post2tex=print-object elem nil style stream)
		     (format stream "}{"))
		   (post2tex=print-object (first (last rest)) nil style stream)
		   (format stream "}"))
	       (progn
					;(post2tex=insert-constant head (length rest))
		 (post2tex=print-object head nil style stream)
					;(write-string (post2tex=number2alpha (length rest)) stream)
		 (write-string "(" stream)
		 (dolist (elem (butlast rest))
		   (post2tex=print-object elem nil style stream)
		   (format stream ","))
		 (post2tex=print-object (first (last rest)) nil style stream)
		 (format stream ")"))))))))

(defmethod post2tex=print-object ((object pdsj+justification) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (ignore last-quantor))
  (if (string-equal (pdsj~status object) :open)
      (write-string "Open " stream)
    (let ((rule (keim~name (just~method object)))
	  (lines (just~premises object)))
      (pprint-logical-block
       (nil nil)
       (write-string "$" stream)
       (write-string (post2tex~rule-2-tex rule) stream)
       (write-string "$ " stream)
       )
      (when lines
	(pprint-logical-block
	 (nil nil)
	 (write-string (post2tex~keim-name (first lines)) stream)
	 (when (rest lines)
	   (dolist (line (rest lines))
	     (write-string "," stream)
	     (write-string (post2tex~keim-name line) stream))))))))

(defmethod post2tex=print-object ((object pdsn+node) last-quantor (style post2tex+fo-infix-style) stream)
  (let ((hyps (pdsn~hyps object))
	(label (keim~name object))
	(formula (node~formula object))
	(just (node~justification object))
	(post2tex*actual-string-counter 0)
	)
    (pprint-logical-block
     (nil nil)
     (write-string " \\pl{" stream)
     (write-string (post2tex~keim-name label) stream)
     (write-string "}" stream)
     )
    (write-string "{" stream)
    (pprint-logical-block
     (nil nil)
     ;;(write-string " " stream)
     (dolist (elem (butlast hyps))
       (write-string (post2tex~keim-name elem) stream)
       (write-string "," stream))
     (write-string (post2tex~keim-name (first (last hyps))) stream)
     (format stream " "))
    (write-string "}{$" stream)
    (post2tex=print-object formula last-quantor style stream)
    (write-string "$}{" stream)
    (post2tex=print-object just last-quantor style stream)
    (write-string "}" stream)
    nil
    ))

(defmethod post2tex=print-object ((object pds+proof-plan) last-quantor (style post2tex+fo-infix-style) stream)
  (let ((lines (prob~proof-steps object)))
    (setq post2tex*environment nil) 
    (write-string post2tex*tabbegin stream)
    (dolist (line lines)
      (terpri stream)
      (post2tex=print-object line last-quantor style stream))
    (terpri stream)
    (write-string post2tex*tabend stream)))

(defmethod post2tex~print-definition (stream (style post2tex+fo-infix-style) &optional (environment post2tex*environment))
  (declare (edited  "22-AUG-1994 16:03")
	   (authors ACSEHN)
	   (input "A stream."  )
	   (effect "The function symbols are written as LaTeX definitions on STREAM." )
	   (value "None."  ))
  (mapcar #'(lambda (pair)
	      (let ((var-const (car pair))
		    (arity (cadr pair)))
		(multiple-value-bind (name realp)
		    (post2tex=name-2-number var-const)
		  (when realp
		    (write-string "\\def\\ptot" stream)
		    (write-string name stream)
		    ;;(post2tex=replace-special-chars (keim~name var-const))
		    (progn;; (not (eql arity 0))
		      (write-string  (post2tex=number2alpha arity) stream))
		    (when (not (eql arity 0))
		      (do ((i 1 (1+ i)))
			  ((> i arity) t)
			(write-string "#" stream)
			(write i :stream stream)))
		    (write-string "{" stream)
		    (if (numberp realp)
			(format stream "{~A_{~A}}"
				(post2tex~keim-name
				 (post2tex=split-name (keim~name var-const)))
				realp)
		      (format stream "{~A}"
			      (post2tex~keim-name (keim~name var-const)))) 
		    (post2tex=print-arity arity stream)
		    (write-string "}" stream)
		    (terpri stream)))))
	  environment)
  NIL)
;;(mapcar #'(lambda (pair)
;;              (multiple-value-bind (name number)
;;                  (post2tex=split-name (post2tex=replace-special-chars (keim~name (car pair))))
;;                (declare (ignore number))
;;                (write-string "\\def\\ptot" stream)
;;                (write-string name stream)
;;                (when (not (eql (cadr pair) 0))
;;                  (write-string  (post2tex=number2alpha (cadr pair)) stream))
;;                (when (not (eql (cadr pair) 0))
;;                  (do ((i 1 (1+ i)))
;;                      ((> i (cadr pair)) t)
;;                    (write-string "#" stream)
;;                    (write i :stream stream)))
;;                (write-string "{" stream)
;;                ;(post2tex~print-object (car pair) style stream)
;;                (write-string "}" stream)
;;                (terpri stream)))
;;          environment)
;;  NIL)


(defun post2tex~write-proof-to-file (proof file)
  (setq post2tex*actual-string-counter 0)
  (with-output-to-string (outstring)
			 (post2tex~print-object proof (post2tex~fo-infix-style) outstring))
  (with-open-file (outstream file :direction :output :if-exists :supersede)
		  (write-string post2tex*documentclass outstream)
		  (terpri outstream)
		  (terpri outstream)
		  (write-string post2tex*dina4 outstream)
		  (terpri outstream)
		  (terpri outstream)
		  (write-string "%% The predefined standard macros for logical symbols." outstream)
		  (terpri outstream)
		  (post2tex~print-predefined outstream)
		  (terpri outstream)
		  (terpri outstream)
		  (write-string "%% The macro-file for the ND-proof style" outstream)
		  (terpri outstream)
		  (write-string post2tex*include-macros outstream)
		  (terpri outstream)
;;MP changed this: first write the signature of the proof, then include file that overdefines constants of the theory signature
		  (write-string "%% The macros defining additional signature in the proof." outstream)
		  (terpri outstream)
		  (post2tex~print-definition outstream (post2tex~fo-infix-style))
		  (when post2tex*predefined-file
		    (write-string "%% The predefined macro-file." outstream)
		    (terpri outstream)
		    (write-string post2tex*predefined-file outstream))
		  (terpri outstream)
		  (write-string post2tex*documentbegin outstream)
		  (terpri outstream)
		  (write-string "%% The ND-proof." outstream)
		  (terpri outstream)
		  (post2tex~print-object proof (post2tex~fo-infix-style) outstream)
		  (terpri outstream)
		  (write-string post2tex*documentend outstream))
  (format T "~%; Proof written on ~A done." file))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Higher Order Style
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod post2tex=print-object ((object term+constant) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((found1 (post2tex=lookup-constant object 0 (term~type object)))
	(found2 (post2tex=lookup-constant object 0 nil))
	(found3 (post2tex=lookup-typed-symbols object)))
    (cond ((and found1 found2 found3)
	   (format stream "\\ptot~A" (post2tex=name-2-number object)))
	  ((and found1 found3)
	   (post2tex=insert-constant object 0 nil)
	   (format stream "\\ptot~A" (post2tex=name-2-number object)))
	  (t
	   (unless found1 (post2tex=insert-constant object 0 (term~type object)))
	   (post2tex=insert-typed-symbols object)
	   (format stream "\\ptot~A~A"
		   (post2tex=name-2-number object)
		   (post2tex=type2alpha (term~type object)))))
    (write-string (post2tex=number2alpha 0) stream)))
	
(defmethod post2tex=print-object ((object term+number) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((number (keim~name object)))
    (if (complexp number) (format stream "(~A+~Ai)" (realpart number) (imagpart number))
      (format stream "~A" number))))

(defmethod post2tex=print-object ((object term+set) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*environment))
  (let ((set (term~normalform object)))
    (format stream "\\{")
    (dolist (x (butlast set))
      (post2tex=print-object x last-quantor style stream)
      (format stream ","))
    (post2tex=print-object (car (last set)) last-quantor style stream)
    (format stream "\\}")))

(defmethod post2tex=print-object ((object term+cyc) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*environment))
  (let ((cycle (term~normalform object)))
    (format stream "(")
    (dolist (x (butlast cycle))
      (post2tex=print-object x last-quantor style stream)
      (format stream ", "))
    (post2tex=print-object (car (last cycle)) last-quantor style stream)
    (format stream ")")))

(defmethod post2tex=print-object ((object term+variable) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((found1 (post2tex=lookup-constant object 0 (term~type object)))
	(found2 (post2tex=lookup-constant object 0 nil))
	(found3 (post2tex=lookup-typed-symbols object)))
    (cond ((and found1 found2 found3)
	   (format stream "\\ptot~A" (post2tex=name-2-number object)))
	  ((and found1 found3)
	   (post2tex=insert-constant object 0 nil)
	   (format stream "\\ptot~A" (post2tex=name-2-number object)))
	  (t
	   (unless found1 (post2tex=insert-constant object 0 (term~type object)))
	   (post2tex=insert-typed-symbols object)
	   (format stream "\\ptot~A~A"
		   (post2tex=name-2-number object)
		   (post2tex=type2alpha (term~type object)))))
    (write-string (post2tex=number2alpha 0) stream)))

(defmethod post2tex=print-object ((object term+schema) last-quantor (style post2tex+ho-infix-style) stream)
  (let ((domain (data~schema-domain object))
	(range (data~schema-range object)))
    (write-string post2tex*kappa stream)
    (post2tex=print-type-list domain stream)
    (write-string "\\lambdot" stream)
    (post2tex=print-object range last-quantor style stream)))

    
(defmethod post2tex=print-object ((object term+abstr) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (let* ((head (data~abstr-bound-var object))
	 (found1 (post2tex=lookup-constant head 0 (term~type object)))
	 (found3 (post2tex=lookup-typed-symbols head)))
    (if (and last-quantor
	     (or (string-equal (keim~name last-quantor) "FORALL")
		 (string-equal (keim~name last-quantor) "EXISTS")))
	(write-string " \\lambdot " stream)
      (write-string "\\lambda " stream))
    (unless found1 (post2tex=insert-constant head 0 (term~type head)))
    (if found3 (format stream "\\ptot~A" (post2tex=name-2-number head))
      (progn
	(post2tex=insert-typed-symbols head)
	(format stream "\\ptot~A~A"
		(post2tex=name-2-number head)
		(post2tex=type2alpha (term~type head)))))
    ;;(post2tex=print-object head nil style stream)
    (write-string (post2tex=number2alpha 0) stream)
    (write-string " \\lambdot " stream)
    (post2tex=print-object (data~abstr-scope object) nil style stream)
    (post2tex=remove-typed-symbols head)))

(defmethod post2tex=print-object ((object term+appl) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (special post2tex*left-bracket post2tex*right-bracket post2tex*brackets post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (cond ((logic~equality-p object)
	 (let ((args (data~appl-arguments object)))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (write-string "=" stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)))
	((logic~disjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*or stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~implication-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*implies stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~conjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*and stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~equivalence-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (write-string post2tex*equiv stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~negation-p object)
	 (let ((args (data~appl-arguments object)))
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*not stream)
	   ;;	   (when post2tex*brackets
	   ;;	     (write-string post2tex*left-bracket stream))
	   (write-string " " stream)
	   (post2tex=print-object (first args) nil style stream)
	   ;;	   (when post2tex*brackets
	   ;;	     (write-string post2tex*right-bracket stream))
	   ))
	((logic~universal-quantification-p object)
	 (let ((quantif-var (logic~quantification-bound-variable object))
	       (scope (logic~quantification-scope object))
	       (new-quantor (data~appl-function object))
					;(head (data~appl-function object))
	       )
	   (if (or (not last-quantor)
		   (not (keim~equal new-quantor last-quantor)))
	       (progn (write-string " " stream)
		      (write-string post2tex*forall stream)
					;(write-string " " stream)
		      (post2tex=print-object quantif-var last-quantor style stream)
		      (when (post2tex=sorted-quantifier-p new-quantor)
			(write-string ":"stream)
			(post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		      (unless (logic~universal-quantification-p scope) 
			(write-string " \\lambdot " stream))
		      (post2tex=print-object scope new-quantor style stream)
		      )
	     (progn (write-string "," stream)
		    (post2tex=print-object quantif-var last-quantor style stream)
		    (when (post2tex=sorted-quantifier-p new-quantor)
		      (write-string ":"stream)
		      (post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		    (unless (logic~universal-quantification-p scope) 
		      (write-string " \\lambdot " stream))
		    (post2tex=print-object scope new-quantor style stream)
		    ))
	   (post2tex=remove-typed-symbols quantif-var)
	   ))
	((logic~existential-quantification-p object)
	 (let ((quantif-var (logic~quantification-bound-variable object))
	       (scope (logic~quantification-scope object))
	       (new-quantor (data~appl-function object))
					;(head (data~appl-function object))
	       )
	   (if (or (not last-quantor)
		   (not (keim~equal new-quantor last-quantor)))
	       (progn (write-string " " stream)
		      (write-string post2tex*exists stream)
		      (post2tex=print-object quantif-var last-quantor style stream)
		      (when (post2tex=sorted-quantifier-p new-quantor)
			(write-string ":"stream)
			(post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
		      (unless (logic~existential-quantification-p scope) 
			(write-string " \\lambdot " stream))
					;(write-string " " stream)
		      (post2tex=print-object scope new-quantor style stream)
		      )
	     (progn (write-string "," stream)
		    (post2tex=print-object quantif-var last-quantor style stream)
		    (when (post2tex=sorted-quantifier-p new-quantor)
		      (write-string ":"stream)
		      (post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		    (unless (logic~existential-quantification-p scope) 
		      (write-string " \\lambdot " stream))
		    (post2tex=print-object scope new-quantor style stream)
		    ))
	   (post2tex=remove-typed-symbols quantif-var)))
	(t
	 (let* ((head (data~appl-function object))
		(rest (data~appl-arguments object))
		(found1 (post2tex=lookup-constant head (length rest) (term~type head)))
		(found2 (post2tex=lookup-constant head (length rest) nil))
		(found3 (unless (or (term~appl-p head)
				    (term~abstr-p head)
				    (term~special-p head))
			  (post2tex=lookup-typed-symbols head))))
	   (if (or (term~appl-p head)
		   (term~abstr-p head)
		   (term~special-p head))
	       (post2tex=print-object head nil style stream)
	     (progn
	       (cond ((and found1 found2 found3) 
		      (format stream "\\ptot~A" (post2tex=name-2-number head)))
		     ((and found1 found3) 
		      (post2tex=insert-constant head (length rest) nil)
		      (format stream "\\ptot~A" (post2tex=name-2-number head)))
		     (found3
		      (post2tex=insert-constant head (length rest) nil)
		      (format stream "\\ptot~A" (post2tex=name-2-number head)))
		     (t 
		      (post2tex=insert-typed-symbols head)
		      (post2tex=insert-constant head (length rest) (term~type head))
		      (format stream "\\ptot~A~A"
			      (post2tex=name-2-number head)
			      (post2tex=type2alpha (term~type head)))))
	       (write-string (post2tex=number2alpha (length rest)) stream)))
	   (write-string "{" stream)
	   (dolist (elem (butlast rest))
	     (post2tex=print-object elem head style stream)
	     (format stream "}{"))
	   (post2tex=print-object (first (last rest)) head style stream)
	   (format stream "}")))
	))

(defmethod post2tex=print-object ((object pdsj+justification) last-quantor (style post2tex+ho-infix-style) stream)
  (declare (ignore last-quantor))
  (if (string-equal (pdsj~status object) :open)
      (let ((lines (just~premises object)))
	(pprint-logical-block
	 (nil nil)
	 (write-string "{\\it Open}" stream))
	(when lines
	  (write-string " " stream)	       
	  (pprint-logical-block
	   (nil nil)
	   (write-string " " stream)
	   (write-string (post2tex~keim-name (first lines)) stream)
	   (when (rest lines)
	     (dolist (line (rest lines))
	       (write-string "," stream)
	       (write-string (post2tex~keim-name line) stream))))
	  (write-string "" stream)))
    (let ((rule (keim~name (just~method object)))
	  (lines (just~premises object)))
      (pprint-logical-block
       (nil nil)
       (write-string "$" stream)
       (write-string (post2tex~rule-2-tex rule) stream)
       (write-string "$" stream))
      (when lines
	(write-string " " stream) 
	(pprint-logical-block
	 (nil nil)
       (write-string " " stream)
       (write-string (post2tex~keim-name (first lines)) stream)
       (when (rest lines)
	 (dolist (line (rest lines))
	   (write-string "," stream)
	   (write-string (post2tex~keim-name line) stream))))
	(write-string "" stream)))))
    
(defmethod post2tex=print-object ((object pdsn+node) last-quantor (style post2tex+ho-infix-style) stream)
  (let ((hyps (post2tex=sort (pdsn~hyps object)))
	(label (keim~name object))
	(formula (node~formula object))
	(just (node~justification object))
	(post2tex*actual-string-counter 0)
	)
    (pprint-logical-block
     (nil nil)
     (write-string " \\pl{" stream)
     (write-string (post2tex~keim-name label) stream)
     (write-string "}" stream)
     )
    (write-string "{" stream)
    (when hyps
      ;;(format T "~%Line ~A has hyp-length:~A" object (length hyps))
      (if (> (length hyps) post2tex*max-hyp-length)
	  (post2tex=print-long-hypotheses hyps stream)
	(progn
	  (pprint-logical-block
       (nil nil)
       ;;(write-string " " stream)
       (dolist (elem (butlast hyps))
	 (write-string (post2tex~keim-name elem) stream)
	 (write-string ", " stream))
       (write-string (post2tex~keim-name (first (last hyps))) stream)
       ))))
    (format stream " ")
    (write-string "}{$" stream)
    (post2tex=print-object formula last-quantor style stream)
    (write-string "$}{" stream)
    (post2tex=print-object just last-quantor style stream)
    (write-string "}" stream)
    nil
    ))

(defmethod post2tex=print-object ((object pds+proof-plan) last-quantor (style post2tex+ho-infix-style) stream)
  (let ((lines (prob~proof-steps object)))
    (setq post2tex*environment nil) 
    (write-string post2tex*tabbegin stream)
    (dolist (line lines)
      (terpri stream)
      (post2tex=print-object line last-quantor style stream))
    (terpri stream)
    (write-string post2tex*tabend stream)))

(defmethod post2tex~print-definition (stream (style post2tex+ho-infix-style)
					     &optional (environment post2tex*environment))
  (declare (edited  "22-AUG-1994 16:03")
	   (authors ACSEHN)
	   (input "A stream."  )
	   (effect "The function symbols are written as LaTeX definitions on STREAM." )
	   (value "None."  ))
  (mapcar #'(lambda (pair)
	      (let ((var-const (car pair))
		    (arity (cadr pair))
		    (type (caddr pair)))
		(multiple-value-bind (name realp)
		    (post2tex=name-2-number var-const)
		  (when realp
		    (write-string "\\def\\ptot" stream)
		    (write-string name stream)
		    (when type (format stream "~A" (post2tex=type2alpha type)))
		    ;;(post2tex=replace-special-chars (keim~name var-const))
		    (progn;; (not (eql arity 0))
		      (write-string  (post2tex=number2alpha arity) stream))
		    (when (not (eql arity 0))
		      (do ((i 1 (1+ i)))
			  ((> i arity) t)
			(write-string "#" stream)
			(write i :stream stream)))
		    (write-string "{" stream)
		    (if (numberp realp)
			(format stream "{~A_{~A}}"
				(post2tex~keim-name
				 (post2tex=split-name (keim~name var-const)))
				realp)
		      (format stream "{~A}"
			      (post2tex~keim-name (keim~name var-const)))) 
		    (when type
		      (format stream "_{[")
		      (post2tex=print-type type stream)
		      (format stream "]}"))
		    (post2tex=print-arity arity stream)
		    (write-string "}" stream)
		    (terpri stream)))))
	  environment)
  NIL)

(defun post2tex~write-ho-proof-to-file (proof file)
  (let* ((post2tex*tabbegin (format nil "\\begin{footnotesize}\\begin{longtable}{p{2.5cm}p{2cm}@{$\\,\\vdash\\,$}p{8cm}p{3cm}}"))
	 (post2tex*tabend "\\end{longtable}\\end{footnotesize}")
	 (post2tex*hyps-list nil)
	 (post2tex*hyp-counter 0)
	 (post2tex*typed-symbols nil)
	 (post2tex*types nil)
	 (string (with-output-to-string (out)
					(post2tex~print-object proof (post2tex~ho-infix-style) out))))
    (with-open-file (outstream file :direction :output :if-exists :supersede)
		    (write-string post2tex*documentclass outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*usepackage outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*dina4 outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string "%% The predefined standard macros for logical symbols." outstream)
		    (terpri outstream)
		    (post2tex~print-predefined outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string "%% The macro-file for the ND-proof style" outstream)
		    (terpri outstream)
		    (write-string post2tex*include-macros outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*documentbegin outstream)
		    (terpri outstream)
;;MP changed this: first write the signature of the proof, then include file that overdefines constants of the theory signature
		    (write-string "%% The macros defining type symbols." outstream)
		    (terpri outstream)
		    (let ((def-string
			    (with-output-to-string (outstring)
						   (post2tex~print-definition outstring (post2tex~ho-infix-style)))))
		      (post2tex~print-types outstream)
		      (terpri outstream)
		      (write-string "%% The macros defining additional signature in the proof." outstream)
		      (terpri outstream)
		      (write-string def-string outstream)) 
		    (terpri outstream)
		    (when post2tex*predefined-file
		      (write-string "%% The predefined macro-file." outstream)
		      (terpri outstream)
		      (write-string post2tex*predefined-file outstream)
		      (terpri outstream))
		    (terpri outstream)
		    ;;(post2tex~print-object proof (post2tex~ho-infix-style) outstream)
		    (write-string "%% The ND-proof." outstream)
		    (terpri outstream)
		    (write-string string outstream)
		    (terpri outstream)
		    (write-string "%% The abbreviations for the Hypotheses." outstream)
		    (terpri outstream)
		    (post2tex=print-hyp-macros outstream)
		    (terpri outstream)
		    (write-string post2tex*documentend outstream))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing of Proof Plans
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod post2tex=print-object ((object pdsn+node) last-quantor (style post2tex+plan-style) stream)
  (let ((hyps (pdsn~hyps object))
	(label (keim~name object))
	(formula (node~formula object))
	;(just (node~justification object))
	)
    (pprint-logical-block
     (nil nil)
     (write-string " " stream)
     (multiple-value-bind (name number) (post2tex=split-name (symbol-name label))
       (if (not (equal number ""))
	   (progn (write-string name stream)
		  (write-string "$_{" stream)
		  (write-string number stream)
		  (write-string "}$" stream))
	 (write-string name stream)))
     (write-string " " stream)
     )
    (write-string " & " stream)
    (pprint-logical-block
     (nil nil)
     (write-string " (" stream)
     (dolist (elem (butlast hyps))
       (multiple-value-bind (name number) (post2tex=split-name (post2tex~keim-name elem))
	 (if (not (equal number ""))
	     (progn (write-string name stream)
		    (write-string "$_{" stream)
		    (write-string  number stream)
		    (write-string "}$" stream))
	   (write-string name stream)))
       (write-string ", " stream))
     (multiple-value-bind (name number) (post2tex=split-name (post2tex~keim-name (first (last hyps))))
       (if (not (equal number ""))
	   (progn (write-string name stream)
		  (write-string "$_{" stream)
		  (write-string number stream)
		  (write-string "}$" stream))
	 (write-string name stream)))
     (format stream ") "))
    (write-string " & $" stream)
    (post2tex=print-object formula last-quantor (post2tex~fo-infix-style) stream)
    ;(write-string "$ & $" stream)
    ;(post2tex=print-object just last-quantor (post2tex~fo-infix-style) stream)
    (write-string "$ \\\\" stream)
    nil
    ))






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Auxiliary Printing Functions 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun post2tex~print-predefined (stream)
  (declare (edited  "22-AUG-1994 16:04")
	   (authors ACSEHN)
	   (input "A stream."  )
	   (effect "The predefined junctors are written as LaTeX definition on STREAM."  )
	   (value  "None." ))
  (declare (special post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (write-string (concatenate 'string "\\def" post2tex*and "{\\wedge}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*or "{\\vee}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*forall "{\\forall}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*exists "{\\exists}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*implies "{\\Rightarrow}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*equiv "{\\Leftrightarrow}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*not "{\\neg}") stream)
  (terpri stream)
  (write-string (concatenate 'string "\\def" post2tex*kappa "{{\\cal K}}") stream)
  (terpri stream)
  (write-string "\\def\\ptotsupportline#1{\\scriptsize (!)#1}" stream)
  (terpri stream)
  (write-string "\\def\\ptotopenline#1{\\scriptsize (?)#1}" stream)
  nil)

(defun post2tex=print-arity (number stream)
  (if (> number 0)
      (progn
	(format stream "(")
	(do ((i 1 (1+ i)))
	    ((>= i number) nil)
	  (format stream "#~A," i))
	(format stream "#~A)" number))
    (format stream "")))

(defun post2tex~print-types (stream)
  (dolist (type post2tex*types)
    (write-string type stream)
    (terpri stream)))

(defun post2tex=print-type (type stream)
  (let ((domain (data~n-domain type))
	(codomain (data~n-range type)))
    (if domain
	(progn
	  (if (and (= (length domain) 1)
		   (type~primitive-p (car domain)))
	      (format stream "~A \\rightarrow ~A" (post2tex=type-2-tex (car domain)) (post2tex=type-2-tex codomain))
	    (progn
	      (format stream "(")
	      (post2tex=print-type-list domain stream)
	      (format stream ")")
	      (format stream "\\rightarrow ~A" (post2tex=type-2-tex codomain)))
	    ))
 	  (format stream "~A" (post2tex=type-2-tex codomain)))))

(defun post2tex=print-type-list (types stream)
  (if (cadr types)
      (progn
	(post2tex=print-type (car types) stream)
	(format stream ",")
	(post2tex=print-type-list (cdr types) stream))
    (post2tex=print-type (car types) stream)))

(defun post2tex=break-lines (stream &optional (add 1))
  (setf post2tex*actual-string-counter (+ post2tex*actual-string-counter add))
  (when (> post2tex*actual-string-counter post2tex*string-counter)
    (write-string post2tex*newline-symbol stream)
    (setf post2tex*actual-string-counter 0)))

(defun post2tex=print-long-hypotheses (lines stream)
  (let ((hyps-macro
	 (assoc lines post2tex*hyps-list :test #'post2tex=subset-equal-p)))
    (if hyps-macro
	(post2tex=print-hyp-macro (cdr hyps-macro) stream)
      (progn
	(let ((new-name (post2tex=new-hyp-name)))
	  (push (cons lines new-name)
		post2tex*hyps-list)
	  (post2tex=print-hyp-macro new-name stream))))))

(defun post2tex=print-hyp-macro (macro stream)
  (write-string
   (format nil
	   "${\\cal H}_{~A}$"
	   (subseq macro 7 (length macro)))
   stream))
  
(defun post2tex=print-hyp-macros (stream)
  (declare (special post2tex*hyps-list))
  (write-string "\\begin{tiny}\\begin{tabular}{p{\\textwidth}}" stream)
  (dolist (pair (reverse post2tex*hyps-list))
    (let ((lines (car pair))
	  (name (cdr pair)))
      (terpri stream)
      (post2tex=print-hyp-macro name stream)
      (write-string " = {" stream)
      (dolist (elem (butlast lines))
	(write-string (post2tex~keim-name elem) stream)
	(write-string ", " stream))
      (write-string (post2tex~keim-name (first (last lines))) stream)
      (write-string "}\\\\[1ex]" stream)
      ))
  (terpri stream)
  (write-string "\\end{tabular}\\end{tiny}" stream))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Auxiliary Functions 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Transformations

(defmethod post2tex=name-2-number ((object term+constant))
  (let* ((name (post2tex=replace-special-chars (keim~name object))))
    (multiple-value-bind (chars number) (post2tex=split-name name)
      (if number
	  (let ((zahl (parse-integer number :junk-allowed t)))
	    (if zahl
		(values (string-upcase (format nil "~A~A" chars (post2tex=number2alpha zahl))) zahl)
	      (values chars t)))
	(values name t)))))

(defmethod post2tex=name-2-number ((object term+variable))
  (let* ((hname (post2tex=replace-special-chars (keim~name object))) ;;MP remove the -
	 (name (etypecase hname
		 (symbol (symbol-name hname))
		 (string hname))))
    (multiple-value-bind (chars number) (post2tex=split-name name)
      (if number
	  (let ((zahl (parse-integer number :junk-allowed t)))
	    (if zahl
		(values (string-upcase (format nil "~A~A" chars (post2tex=number2alpha zahl))) zahl)
	      (values chars t)))
	(values name t)))))

(defmethod post2tex=name-2-number ((object t))
  (values nil nil))

(defun post2tex=number2alpha (number)
  (declare (edited  "23-AUG-1994 13:45")
	   (authors ACSEHN)
	   (input "A number"  )
	   (effect "None." )
	   (value "A string of the character where the ASCII number of the character ``a'' is added to NUMBER."  ))
  (let ((number-string (format nil "~A" number))
	(result ""))
    (dotimes (i (length number-string) (reverse result))
      (setq result (concatenate 'string
				(string-downcase
				 (format nil "~A"
					 (code-char (+ 65 (parse-integer
							   (format nil "~A"
								   (aref number-string i)))))))
				result)))))

(defun post2tex=type2alpha (type)
  (declare (edited  "06-AUG-1997 16:00")
	   (authors Sorge)
	   (input "A type"  )
	   (effect "None." )
	   (value "A string as ASCII representation of a type."  ))
  (let* ((domain (data~n-domain type))
	 (range (data~n-range type))
	 (codomain  (if (type~appl-p range)
			(format nil "CST~A~A" (data~appl-function range) 
				(post2tex=type-list2alpha (data~appl-arguments range)))
		      (format nil "~A" range))))
    (if domain
	(concatenate 'string
		     (format nil "LBR")
		     (post2tex=type-list2alpha domain)
		     (format nil "RBR")
		     (format nil "AR~A" codomain)
		     )
      codomain)))

(defun post2tex=type-list2alpha (list)
  (if (cadr list)
      (concatenate 'string
		   (format nil "~AKOM" (post2tex=type2alpha (car list)))
		   (post2tex=type-list2alpha (cdr list)))
    (format nil "~A" (post2tex=type2alpha (car list)))))

(defun post2tex=integer-2-charlist (number)
  (let ((list (if (= number 0) (list (digit-char number))
		(do ((n (floor (/ number 10)) (floor (/ n 10)))
		     (m number (floor (/ m 10)))
		     (list '(:dummy) (append list
					     (list (digit-char (- m (* n 10))))))) 
		    ((= m 0) (reverse (cdr list)))))))
    (make-array (length list) 
		:element-type 'character
		:initial-contents list)))

(defun post2tex~rule-2-tex (rulename)
  (cond ((string-equal rulename "ForallE")
	 "\\posttotexforall E")
	((string-equal rulename "ForallE*")
	 "\\posttotexforall E*")
	((string-equal rulename "NotE")
	 "\\posttotexnot E")
	((string-equal rulename "ExistsE")
	 "\\posttotexexists E")
	((string-equal rulename "OrE")
	 "{\\posttotexor} E")
	((string-equal rulename "EquivE")
	 "{\\posttotexequiv} E")
	((or (string-equal rulename "AndE")
	     (string-equal rulename "and-E"))
	 "{\\posttotexand} E")
	((or (string-equal rulename "AndE*")
	     (string-equal rulename "and-E*"))
	 "{\\posttotexand} E*")
	((string-equal rulename "NotI")
	 "\\posttotexnot I")
	((string-equal rulename "ImpE")
	 "{\\posttoteximplies} E")
	((string-equal rulename "ForallI")
	 "\\posttotexforall I")
	((string-equal rulename "ForallI*")
	 "\\posttotexforall I*")
	((string-equal rulename "ExistsI")
	 "\\posttotexexists I")
	((string-equal rulename "EquivI")
	 "{\\posttotexequiv} I")
	((or (string-equal rulename "AndI")
	     (string-equal rulename "And-I")
	     (string-equal rulename "and-I"))
	 "{\\posttotexand} I")
	((or (string-equal rulename "AndI*")
	     (string-equal rulename "And-I*")
	     (string-equal rulename "and-I*"))
	 "{\\posttotexand} I*")
	((string-equal rulename "OrI")
	 "{\\posttotexor} I")
	((string-equal rulename "OrIL")
	 "{\\posttotexor} I_L")
	((string-equal rulename "OrIR")
	 "{\\posttotexor} I_R")
	((string-equal rulename "ImpI")
	 "{\\posttoteximplies} I")
	((string-equal rulename "AndER")
	 "{\\posttotexand} E_R")
	((string-equal rulename "AndEL")
	 "{\\posttotexand} E_L")
	((string-equal rulename "EquivER")
	 "{\\posttotexequiv} E_R")
	((string-equal rulename "EquivEL")
	 "{\\posttotexequiv} E_L")
	((string-equal rulename "EquivSubst")
	 "{\\posttotexequiv} Subst")
	((string-equal rulename "Equiv2=")
	 "{\\posttotexequiv} 2{=}")
	((string-equal rulename "=2Equiv")
	 "{=}2{\\posttotexequiv}")
	((string-equal rulename "LR2Equiv")
	 "LR2{\\posttotexequiv}")
	((string-equal rulename "imp2or")
	 "{\\posttoteximplies} 2\\posttotexor")
	((string-equal rulename "or2imp")
	 "\\posttotexor 2{\\posttoteximplies}")
	((string-equal rulename "NotNotI")
	 "\\posttotexnot\\posttotexnot I")
	((string-equal rulename "NotNotE")
	 "\\posttotexnot\\posttotexnot E")
	((string-equal rulename "OrMP")
	 "{\\posttotexor} MP")
	((string-equal rulename "beta-normalize")
	 "\\beta\\mbox{-norm}")
	((string-equal rulename "beta-expand")
	 "\\beta\\mbox{-exp}")
	((string-equal rulename "pushneg")
	 "\\mbox{Push}\\posttotexnot")
	((string-equal rulename "pullneg")
	 "\\mbox{Pull}\\posttotexnot")
	((string-equal rulename "neg=i")
	 "\\neq I")
	((string-equal rulename "neg=sym")
	 "\\neq SYM")
	((string-equal rulename "trueI")
	 "\\top I")
	((symbolp rulename)
	 (format nil "\\mbox{~:(~A~)}" (symbol-name rulename)))
	(t (format nil "\\mbox{~:(~A~)}" rulename))))

(defun post2tex=type-2-tex (type)
  (if (type~appl-p type)
		   (format nil "~A(~{~A,~}~A)"
			   (post2tex=type-2-tex (data~appl-function type))
			   (mapcar #'post2tex=type-2-tex (butlast (data~appl-arguments type)))
			   (post2tex=type-2-tex (car (last (data~appl-arguments type)))))
  (let ((typename (keim~name type)))
    (flet ((insert-type (macro letter)
			(setf post2tex*types (adjoin (format nil "\\def~A{~A}" macro letter) post2tex*types :test #'string=))
			macro))
      (cond ((string-equal typename "o")
	     (insert-type "\\ptotomicron" "o"))
	    ((string-equal typename "i")
	     (insert-type "\\ptotiota" "\\iota"))
	    ((string-equal typename "aa")
	     (insert-type "\\ptotalpha" "\\alpha"))
	    ((string-equal typename "bb")
	     (insert-type "\\ptotbeta" "\\beta"))
	    ((string-equal typename "cc")
	     (insert-type "\\ptotgamma" "\\gamma"))
	    ((string-equal typename "ee")
	     (insert-type "\\ptotepsilon" "\\epsilon"))
	    ((string-equal typename "ff")
	     (insert-type "\\ptotzeta" "\\zeta"))
	    ((string-equal typename "tau")
	     (insert-type "\\ptottau" "\\tau"))
	    ((string-equal typename "sigma")
	     (insert-type "\\ptotsigma" "\\sigma"))
	    ((string-equal typename "rho")
	     (insert-type "\\ptotrho" "\\rho"))
	    ((string-equal typename "upsilon")
	     (insert-type "\\ptotupsilon" "\\upsilon"))
	    ((string-equal typename "kappa")
	     (insert-type "\\ptotkappa" "\\kappa"))
	    ((string-equal typename "num")
	     (insert-type "\\ptotnu" "\\nu"))
	    (T 
	     (insert-type (concatenate 'string "\\ptot" (string typename))
			  typename)))))))


;;; Global Variable Manipulations

(defun post2tex=insert-typed-symbols (symbol)
  (declare (special post2tex*typed-symbols))
  (push (keim~name symbol) post2tex*typed-symbols))

(defun post2tex=remove-typed-symbols (symbol)
  (declare (special post2tex*typed-symbols))
  (setf post2tex*typed-symbols (remove (keim~name symbol) post2tex*typed-symbols :test #'string-equal)))

(defun post2tex=lookup-typed-symbols (symbol &optional (typed-symbols post2tex*typed-symbols))
  (find (keim~name symbol) typed-symbols :test #'string-equal))

(defun post2tex=insert-type (type)
  (push type post2tex*types))

(defun post2tex=lookup-type (type &optional (types post2tex*types))
  (find type types))

;;;(defun post2tex=insert-symbol

(defun post2tex=insert-constant (constant arity type)
  (declare (special post2tex*environment))
  (when (not (post2tex=lookup-constant constant arity type))
    (setq post2tex*environment (pushnew (list constant arity type) post2tex*environment :test #'post2tex=equal-p)))
  (prog1 post2tex*environment))

(defun post2tex=lookup-constant (constant arity type &optional (store post2tex*environment))
  (first (remove-if-not #'(lambda (pair) (post2tex=equal-p pair (list constant arity type)))
			store)))


(defun post2tex~set-predefined-symbols (file-name)
  (declare (edited  "22-MAY-1996")
	   (authors Lassaad)
	   (input   "file name")
	   (effect  "Imports the given file into the resulted tex file." )
	   (value   "None"))
  (setq post2tex*predefined-file
	(format nil "\\input{~A}" file-name)))

(defun post2tex~reset-predefined-symbols ()
  (declare (edited  "23-MAY-1996")
	   (authors Lassaad)
	   (input   "None")
	   (effect  "resets post2tex*predefined-file to nil." )
	   (value   "None"))
  (setq post2tex*predefined-file nil))


;;; Predicates

(defgeneric post2tex=equal-p (obj1 obj2)
  (:method ((obj1 term+number) (obj2 term+number))
	   (data~equal obj1 obj2))
  (:method ((obj1 term+variable) (obj2 term+variable))
	   (string= (keim~name obj1) (keim~name obj2))) ;  (data~equal obj1 obj2)
  (:method ((obj1 term+constant) (obj2 term+variable))
	   (string= (keim~name obj1) (keim~name obj2)))
  (:method ((obj1 term+variable) (obj2 term+constant))
	   (string= (keim~name obj1) (keim~name obj2)))
  (:method ((obj1 term+constant) (obj2 term+constant))
	   (cond ((and (term~special-p obj1)(term~special-p obj2))
		  (every #'post2tex=equal-p (term~normalform obj1)(term~normalform obj2)))
		 ((or (term~special-p obj1)(term~special-p obj2)) nil)
		 (T
		  (string= (keim~name obj1) (keim~name obj2))))) ;  (string= (keim~name obj1) (keim~name obj2))
  (:method ((obj1 term+appl) (obj2 term+appl))
	   (data~equal obj1 obj2))
  (:method ((obj1 term+abstr) (obj2 term+abstr))
	   (data~equal obj1 obj2))
  #+weg(:method ((obj1 term+term) (obj2 term+term))
	   (data~equal obj1 obj2))
  (:method ((obj1 keim+object) (obj2 keim+object))
	   (keim~equal obj1 obj2))
  (:method ((obj1 list) (obj2 list))
	   (every #'post2tex=equal-p obj1 obj2))
  (:method ((obj1 t) (obj2 t))
	   (eq obj1 obj2)))

(defgeneric post2tex=equality-p (object)
  (:method ((object term+constant))
	   (string-equal (keim~name object) "="))
  (:method ((object t))
	   nil))

(defgeneric post2tex=sorted-quantifier-p (object)
  (:method ((object term+constant))
	   (or (string-equal (keim~name object) "forall-sort")
	       (string-equal (keim~name object) "exists-sort")))
  (:method ((object t))
	   nil))

(defun post2tex=subset-equal-p (set-1 set-2)
  (and (subsetp set-1 set-2)
       (subsetp set-2 set-1)))
       
(defun post2tex=line-number-less-p (line-1 line-2)
  (let* ((line-label-1 (symbol-name (keim~name line-1)))
	 (number-or-nil-1
	  (parse-integer
	   (string-left-trim "L" line-label-1) :junk-allowed t))
	 (line-label-2 (symbol-name (keim~name line-2)))
	 (number-or-nil-2
	  (parse-integer
	   (string-left-trim "L" line-label-2) :junk-allowed t))
	 (number-1 (if number-or-nil-1
		       number-or-nil-1
		     0))
	 (number-2 (if number-or-nil-2
		       number-or-nil-2
		     0)))
    (or (< number-1 number-2)
	(and (= number-1 number-2)	
	     (string< line-label-1 line-label-2)))))
	 

;;; Copying

(defmethod keim~copy ((table hash-table) &key (explode :all-classes) share preserve downto)
  (let ((new-table (make-hash-table :test #'equal)))
    (maphash #'(lambda (key val)
		 (setf (gethash key new-table)
		       val))
	     table)
    new-table))

(defmethod keim~copy ((ndproof pds+proof-plan) &key (explode :all-classes) share preserve downto)
  (let ((new-proof (pds~proof-plan-create (gentemp (keim~name ndproof)))))
    (setf (prob~proof-steps new-proof) (keim~copy (prob~proof-steps ndproof) :explode explode :share share :preserve preserve :downto downto))
    (setf (pds~open-nodes new-proof) (keim~copy (pds~open-nodes ndproof)  :explode explode :share share :preserve preserve :downto downto))
    (setf (prob~proof-root new-proof) (keim~copy (prob~proof-root ndproof)  :explode explode :share share :preserve preserve :downto downto))
    (setf (pds~label-node-hashtable new-proof) (keim~copy (pds~label-node-hashtable ndproof)  :explode explode :share share :preserve preserve :downto downto))
    (setf (pds~environment new-proof) (keim~copy (pds~environment ndproof)  :explode explode :share share :preserve preserve :downto downto))
    new-proof))

(defmethod keim~copy ((object env+environment) &key (explode :all-classes) share preserve downto)
  (declare (ignore  explode share preserve downto))
  (env~copy object))

(defmethod keim~copy ((ndline pdsn+node) &key (explode :all-classes) share preserve downto)
  (declare (ignore  explode share preserve downto))
  (pdsn~copy ndline))


;;; Naming and String-Manipulations

(defgeneric post2tex~keim-name (object)
  (:method ((str string))
	   (labels ((replace-char (char)
				  (if (stringp char) char
				    (case char
				      (#\_ "\\_")
				      (#\$ "\\$")
				      (#\^ "\\^")  ;;MP put additional things here
				      (T   (string char))))))
	     (format nil "~:(~A~)"
		     (reduce #'(lambda (string char)
			   (concatenate 'string (replace-char string)(replace-char char)))
		       str))))
  (:method ((sym symbol))
	   (post2tex~keim-name (symbol-name sym)))
  (:method ((ndline pdsn+node))
	   (post2tex~keim-name (keim~name ndline))))

(defun post2tex=split-name (name)
  (declare (edited  "22-AUG-1994 14:21")
	   (authors ACSEHN)
	   (input "A symbol name, NAME."  )
	   (effect "None." )
	   (value "The name is splitted into two parts:"
		  "1. The part consisting only of characters."
		  "2. The part representing a number."))
  (let* ((name (etypecase name
		(symbol (symbol-name name))
		(string name)))
	 (index (do ((i 0 (1+ i)))
		    ((or  (>= i (length name))
			  (digit-char-p (char name i))) i)))
	 (symbol-name 	(subseq name 0 index))
	 (symbol-number (subseq name index (length name))))
    (values symbol-name symbol-number)))

(defun post2tex=replace-special-chars (name)
  (declare (edited  "23-AUG-1994 16:41")
	   (authors ACSEHN)
	   (input "A name."  )
	   (effect "None." )
	   (value "The name where special chars are replaced by longer names."
		  "This function should be used for the name of a \TeX-definition."))
  (labels ((replace-char (char)
			 (if (stringp char) char
			   (case char
			     (#\_ "underline")
			     (#\^ "hat")
			     (#\! "exclamation")  ;;MP put additional things here
			     (#\- "minus") 
			     (T   (string char))))))
    (let ((name (etypecase name
		  (symbol (symbol-name name))
		  (string name))))
      (format nil "~A" (reduce #'(lambda (string char)
				   (concatenate 'string (replace-char string)(replace-char char)))
			       name)))))

(defun post2tex=new-hyp-name ()
  (format nil "HYPSET-~A" (incf post2tex*hyp-counter)))

;;(defun post2tex=numbered-post-variable-p (symbol-name)
;;  (let* ((first-char (char symbol-name 0))
;;         (rest (subseq symbol-name 1))
;;         (number (parse-integer rest :junk-allowed T)))
;;    (if (and (characterp first-char)
;;             (integerp number))
;;        T
;;      NIL)))


;;(defun post2tex=numbered-post-variable (symbol-name)
;;  (declare (edited  "22-AUG-1994 11:43")
;;           (authors ACSEHN)
;;           (input "A symbol name of a POST variable with a number as a suffix."  )
;;           (effect "None." )
;;           (value "The name of the variable with the number underscored."  )
;;           (example "x123 --> x_{123}" ))
;;  (let* ((first-char (char symbol-name 0))
;;         (rest (subseq symbol-name 1))
;;         (number (parse-integer rest :junk-allowed T)))
;;    (if (post2tex=numbered-post-variable-p symbol-name)
;;        (format nil "~A_{~A}" first-char number)
;;      symbol-name)))


;;; Sorting

(defun post2tex~sorted-structure (object)
  (declare (edited  "22-MAY-1996")
	   (authors Lassaad)
	   (input   "a data structure (line list,nd proof or plan state)")
	   (effect  "changes the data structure so that the nd lines are sorted.")
	   (value   "the data structure with sorted nd lines."))
  (post2tex=sort object))

(defgeneric post2tex=sort (object)
  (:method ((object list))
	   (let* ((new-list (copy-list object)))
	     (sort new-list #'post2tex=line-number-less-p)))
  (:method ((proof pds+proof-plan))
	   (let* ((object (keim~copy proof))
		  (proof-lines (reverse (pds~linearize-plan (prob~proof-root object)))))
	     (setf (prob~proof-steps object) proof-lines) 
	     object)))

#| MP: above sorting is more natural than line-numbers
(defgeneric post2tex=sort (object)
  (:method ((object list))
	   (let* ((new-list (copy-list object)))
	     (sort new-list #'post2tex=line-number-less-p)))
  (:method ((proof pds+proof-plan))
	   (let* ((object (keim~copy proof))
		  (proof-lines (prob~proof-steps object)))
	     (setf (prob~proof-steps object) (post2tex=sort proof-lines))
	     object)))
|#



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing Problems, Theorems etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun post2tex~write-problems-to-file (problems file &key (style :ho))
  (declare (edited  "11-NOV-2004")
	   (authors Sorge)
	   (input   "A list of problems and a file.")
	   (effect  "Writes a LaTeX file.")
	   (value   "Undefined."))
  (let* ((post2tex*tabbegin (format nil "\\begin{footnotesize}\\begin{longtable}{p{2.5cm}p{2cm}@{$\\,\\vdash\\,$}p{8cm}p{3cm}}"))
	 (post2tex*tabend "\\end{longtable}\\end{footnotesize}")
	 (post2tex*hyps-list nil)
	 (post2tex*hyp-counter 0)
	 (post2tex*typed-symbols nil)
	 (post2tex*types nil)
	 (post2tex*environment nil)
	 (style (if (string-equal style :ho) (post2tex~ho-infix-style) (post2tex~fo-infix-style)))
	 (string (apply 'concatenate
			(cons 'string
			      (mapcar #'(lambda (problem)
					  (with-output-to-string (out)
								 (post2tex~print-object problem style out)))
				      problems)))))
    (with-open-file (outstream file :direction :output :if-exists :supersede)
		    (write-string post2tex*documentclass outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*usepackage outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*dina4 outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string "%% The predefined standard macros for logical symbols." outstream)
		    (terpri outstream)
		    (post2tex~print-predefined outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string "%% The macro-file for the ND-proof style" outstream)
		    (terpri outstream)
		    (write-string post2tex*include-macros outstream)
		    (terpri outstream)
		    (terpri outstream)
		    (write-string post2tex*documentbegin outstream)
		    (terpri outstream)
;;MP changed this: first write the signature of the proof, then include file that overdefines constants of the theory signature
		    (write-string "%% The macros defining type symbols." outstream)
		    (terpri outstream)
		    (let ((def-string
			    (with-output-to-string (outstring)
						   (post2tex~print-definition outstring style))))
		      (post2tex~print-types outstream)
		      (terpri outstream)
		      (write-string "%% The macros defining additional signature in the proof." outstream)
		      (terpri outstream)
		      (write-string def-string outstream)) 
		    (terpri outstream)
		    (when post2tex*predefined-file
		      (write-string "%% The predefined macro-file." outstream)
		      (terpri outstream)
		      (write-string post2tex*predefined-file outstream)
		      (terpri outstream))
		    (terpri outstream)
		    ;;(post2tex~print-object proof (post2tex~fo-infix-style) outstream)
		    (write-string "%% The Problems." outstream)
		    (terpri outstream)
		    (write-string string outstream)
		    (terpri outstream)
		    ;;(write-string "%% The abbreviations for the Hypotheses." outstream)
		    ;;(terpri outstream)
		    ;;(post2tex=print-hyp-macros outstream)
		    ;;(terpri outstream)
		    (write-string post2tex*documentend outstream))))


(defmethod post2tex=print-object ((object prob+problem) last-quantor (style post2tex+ho-infix-style) stream)
  (let ((conc (prob~conclusion object))
	(ass (prob~assumptions object)))
    (write-string (format nil "\\noindent Problem ~A: " (keim~name object)) stream)
    (write-string "\\\\" stream)
    (dolist (a ass)
      (terpri stream)
      (write-string (format nil "Assumption ~A: $" (keim~name a)) stream)
      (post2tex=print-object (node~formula a) last-quantor style stream)
      (write-string (format nil "$") stream)
      (write-string "\\\\" stream))
    (terpri stream)
    (write-string (format nil "Conclusion: $") stream)
    (post2tex=print-object (node~formula conc) last-quantor style stream)
    (write-string (format nil "$") stream)
    (write-string "\\\\" stream)
    (terpri stream)
    (terpri stream)))

(defmethod post2tex=print-object ((object prob+problem) last-quantor (style post2tex+fo-infix-style) stream)
  (let ((conc (prob~conclusion object))
	(ass (prob~assumptions object)))
    (write-string (format nil "\\noindent Problem ~A: " (keim~name object)) stream)
    (write-string "\\\\" stream)
    (dolist (a ass)
      (terpri stream)
      (write-string (format nil "Assumption ~A: $" (keim~name a)) stream)
      (post2tex=print-object (node~formula a) last-quantor style stream)
      (write-string (format nil "$") stream)
      (write-string "\\\\" stream))
    (terpri stream)
    (write-string (format nil "Conclusion: $") stream)
    (post2tex=print-object (node~formula conc) last-quantor style stream)
    (write-string (format nil "$") stream)
    (write-string "\\\\" stream)
    (terpri stream)
    (terpri stream)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; New First Order Style
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod post2tex=print-object ((object term+constant) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (post2tex=insert-constant object 0 nil)
  (format stream "\\ptot~A" (post2tex=name-2-number object))
  (write-string (post2tex=number2alpha 0) stream))
	
(defmethod post2tex=print-object ((object term+number) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (let ((number (keim~name object)))
    (if (complexp number) (format stream "(~A+~Ai)" (realpart number) (imagpart number))
      (format stream "~A" number))))

(defmethod post2tex=print-object ((object term+set) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment))
  (let ((set (term~normalform object)))
    (format stream "\\{")
    (dolist (x (butlast set))
      (post2tex=print-object x last-quantor style stream)
      (format stream ","))
    (post2tex=print-object (car (last set)) last-quantor style stream)
    (format stream "\\}")))

(defmethod post2tex=print-object ((object term+cyc) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment))
  (let ((cycle (term~normalform object)))
    (format stream "(")
    (dolist (x (butlast cycle))
      (post2tex=print-object x last-quantor style stream)
      (format stream ", "))
    (post2tex=print-object (car (last cycle)) last-quantor style stream)
    (format stream ")")))

(defmethod post2tex=print-object ((object term+variable) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*environment)
	   (ignore last-quantor))
  (post2tex=insert-constant object 0 nil)
  (format stream "\\ptot~A" (post2tex=name-2-number object))
  (write-string (post2tex=number2alpha 0) stream))

(defmethod post2tex=print-object ((object term+schema) last-quantor (style post2tex+fo-infix-style) stream)
  (let ((domain (data~schema-domain object))
	(range (data~schema-range object)))
    (write-string post2tex*kappa stream)
    (post2tex=print-type-list domain stream)
    (write-string "\\lambdot" stream)
    (post2tex=print-object range last-quantor style stream)))

    
(defmethod post2tex=print-object ((object term+abstr) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (let* ((head (data~abstr-bound-var object)))
    (if (and last-quantor
	     (or (string-equal (keim~name last-quantor) "FORALL")
		 (string-equal (keim~name last-quantor) "EXISTS")))
	(write-string " \\lambdot " stream)
      (write-string "\\lambda " stream))
    (post2tex=insert-constant head 0 nil)
    ;;(post2tex=print-object head nil style stream)
    (write-string (post2tex=number2alpha 0) stream)
    (write-string " \\lambdot " stream)
    (post2tex=print-object (data~abstr-scope object) nil style stream)))

(defmethod post2tex=print-object ((object term+appl) last-quantor (style post2tex+fo-infix-style) stream)
  (declare (special post2tex*left-bracket post2tex*right-bracket post2tex*brackets post2tex*and post2tex*or post2tex*implies post2tex*equiv post2tex*not post2tex*forall post2tex*exists))
  (cond ((logic~equality-p object)
	 (let ((args (data~appl-arguments object)))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (write-string "=" stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)))
	((logic~disjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*or stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~implication-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*implies stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~conjunction-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*and stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~equivalence-p object)
	 (let ((args (data~appl-arguments object)))
	   (when post2tex*brackets
	     (write-string post2tex*left-bracket stream))
	   (post2tex=print-object (first args) nil style stream)
	   (post2tex=break-lines stream 6)
	   (write-string " " stream)
	   (write-string post2tex*equiv stream)
	   (write-string " " stream)
	   (post2tex=print-object (second args) nil style stream)
	   (when post2tex*brackets
	     (write-string post2tex*right-bracket stream))))
	((logic~negation-p object)
	 (let ((args (data~appl-arguments object)))
	   (write-string " " stream)
	   (post2tex=break-lines stream 6)
	   (write-string post2tex*not stream)
	   ;;	   (when post2tex*brackets
	   ;;	     (write-string post2tex*left-bracket stream))
	   (write-string " " stream)
	   (post2tex=print-object (first args) nil style stream)
	   ;;	   (when post2tex*brackets
	   ;;	     (write-string post2tex*right-bracket stream))
	   ))
	((logic~universal-quantification-p object)
	 (let ((quantif-var (logic~quantification-bound-variable object))
	       (scope (logic~quantification-scope object))
	       (new-quantor (data~appl-function object))
					;(head (data~appl-function object))
	       )
	   (if (or (not last-quantor)
		   (not (keim~equal new-quantor last-quantor)))
	       (progn (write-string " " stream)
		      (write-string post2tex*forall stream)
					;(write-string " " stream)
		      (post2tex=print-object quantif-var last-quantor style stream)
		      (when (post2tex=sorted-quantifier-p new-quantor)
			(write-string ":"stream)
			(post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		      (unless (logic~universal-quantification-p scope) 
			(write-string " \\lambdot " stream))
		      (post2tex=print-object scope new-quantor style stream)
		      )
	     (progn (write-string "," stream)
		    (post2tex=print-object quantif-var last-quantor style stream)
		    (when (post2tex=sorted-quantifier-p new-quantor)
		      (write-string ":"stream)
		      (post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		    (unless (logic~universal-quantification-p scope) 
		      (write-string " \\lambdot " stream))
		    (post2tex=print-object scope new-quantor style stream)
		    ))
	   (post2tex=remove-typed-symbols quantif-var)
	   ))
	((logic~existential-quantification-p object)
	 (let ((quantif-var (logic~quantification-bound-variable object))
	       (scope (logic~quantification-scope object))
	       (new-quantor (data~appl-function object))
					;(head (data~appl-function object))
	       )
	   (if (or (not last-quantor)
		   (not (keim~equal new-quantor last-quantor)))
	       (progn (write-string " " stream)
		      (write-string post2tex*exists stream)
		      (post2tex=print-object quantif-var last-quantor style stream)
		      (when (post2tex=sorted-quantifier-p new-quantor)
			(write-string ":"stream)
			(post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
		      (unless (logic~existential-quantification-p scope) 
			(write-string " \\lambdot " stream))
					;(write-string " " stream)
		      (post2tex=print-object scope new-quantor style stream)
		      )
	     (progn (write-string "," stream)
		    (post2tex=print-object quantif-var last-quantor style stream)
		    (when (post2tex=sorted-quantifier-p new-quantor)
		      (write-string ":"stream)
		      (post2tex=print-object (second (data~appl-arguments object)) last-quantor style stream))
					;(write-string " " stream)
		    (unless (logic~existential-quantification-p scope) 
		      (write-string " \\lambdot " stream))
		    (post2tex=print-object scope new-quantor style stream)
		    ))
	   (post2tex=remove-typed-symbols quantif-var)))
	(t
	 (let* ((head (data~appl-function object))
		(rest (data~appl-arguments object)))
	   (if (or (term~appl-p head)
		   (term~abstr-p head)
		   (term~special-p head))
	       (post2tex=print-object head nil style stream)
	     (progn
	       (post2tex=insert-constant head (length rest) nil)
	       (format stream "\\ptot~A" (post2tex=name-2-number head))
	       (write-string (post2tex=number2alpha (length rest)) stream)))
	   (write-string "{" stream)
	   (dolist (elem (butlast rest))
	     (post2tex=print-object elem head style stream)
	     (format stream "}{"))
	   (post2tex=print-object (first (last rest)) head style stream)
	   (format stream "}")))
	))

