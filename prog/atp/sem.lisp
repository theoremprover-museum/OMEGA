;;; -*- syntax: common-lisp; package: OMEGA; base: 10; mode: LISP -*-
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
;;                                                                          ;;
;;   Copyright (C) 1996 by AG Siekmann, Fachbereich Informatik,             ;;
;;   Universitaet des Saarlandes, Saarbruecken, Germany.                    ;;
;;   All rights reserved.                                                   ;;
;;   For information about this program, write to:                          ;;
;;     PROVERB Project                                                      ;;
;;     AG Siekmann/FB Informatik                                            ;;
;;     Universitaet des Saarlandes                                          ;;
;;     Bau 36, 4. Stock                                                     ;;
;;     D-66041 Saarbruecken                                                 ;;
;;     Germany                                                              ;;
;;   electronic mail: proverb@cs.uni-sb.de                                  ;;
;;                                                                          ;;
;;   The author makes no representations about the suitability of this      ;;
;;   software for any purpose.  It is provided "AS IS" without express or   ;;
;;   implied warranty.  In particular, it must be understood that this      ;;
;;   software is an experimental version, and is not suitable for use in    ;;
;;   any safety-critical application, and the author denies a license for   ;;
;;   such use.                                                              ;;
;;                                                                          ;;
;;   You may use, copy, modify and distribute this software for any         ;;
;;   noncommercial and non-safety-critical purpose.  Use of this software   ;;
;;   in a commercial product is not included under this license.  You must  ;;
;;   maintain this copyright statement in all copies of this software that  ;;
;;   you modify or distribute.                                              ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;

(in-package :omega)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MathWeb Interface to SEM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun sem~enter   ()       (serv~enter   "SEM"))
(defun sem~leave   ()       (serv~leave   "SEM"))
(defun sem~restart ()       (serv~restart "SEM"))
(defun sem~apply   (method) (serv~apply   "SEM" method :timeout 600))


(defun sem~call-sem (input)
  (declare (edited  "30-OCT-2001")
	   (authors Pollet)
	   (input   "A list with two strings. The first is the problem in SEM syntax,"
		    "the second is for the options/switches given to SEM.")
	   (effect  "Calls SEM on the given problem with given switches.")
	   (value   "A string containing the output generated by SEM, or "
		    "NIL when SEM did not produce any output."))
  (sem~enter)
  
  ;;(let ((result 
  ;;	 (rest (assoc 'output
  ;;		      (read-from-string
  ;;		       (sem~apply
  ;;			(format nil "prove(\"~A\" options: \"~A\" replyWith: foo(state: unit output: unit))"
  ;;				(car input)(cadr input))))))))
  ;;	(when (not (eq result 'unit)) result)))

  ;; for some reasons (why ever) there is now an additional quote in the output from sem~apply,
  ;; to take care of this I added a new case AMEIER

  (let* ((sem-out (read-from-string
		   (sem~apply
		    (format nil "prove(\"~A\" options: \"~A\" replyWith: foo(state: unit output: unit))"
			    (car input)(cadr input)))))
	 (check-out (if (equal (first sem-out) 'quote)
			(second sem-out)
		      sem-out))
	 (result (rest (assoc 'output check-out))))
    (when (not (eq result 'unit)) result)))
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Creating a standard SEM input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun sem~sem-input (&key sorts variables functions clauses (solutions 1))
  (declare (edited  "23-SEP-2001")
	   (authors Pollet)
	   (input   "Four lists of strings and an integer.")
	   (effect  "None.")
	   (value   "A list of strings containing the input specification for SEM."))
  (list (concatenate
	 'string
	 (format nil "~%%Sorts ~{~%(~A)~}" sorts)
	 (format nil "~%%Functions~{~%{~A}~}" functions)
	 (format nil "~%%Variables ~{~%<~A>~}" variables)
	 (format nil "~%%Clauses ~{~%[~A]~}" clauses))
	(format nil "-m~A" solutions)))
  



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translating SEM output into lists of models
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun sem~translate-models (input output)
  (declare (edited  "23-SEP-2001")
           (authors Pollet)
           (input   "Two strings: the input to Sem and its computed output.")
           (effect  "none")
           (value   "A string containing a list of models."))
  (let ((domain-list (sem=get-domain input))
	(models (sem=read-models output)))
    (mapcar #'(lambda (model)(list
			      (first model) '(should-contain-time)
			      (list (list 'domain domain-list)
				    (rest model))))
				    models)))

;                              (format output-stream "~%(~a ()(" (first model))
;                              (format output-stream "~%  (domain  ~a)" domain-list)
;                              (format output-stream "~%  ~a" (rest model))
;                              (format output-stream "~%))~%"))))))
  
;;Here comes a simple but not 100% perfect parser.

;;this works for sem~sem-input: the domains are lists at the beginning of the buffer
;;of the form ( bla : bla1, bla2 ...)  
(defun sem=get-domain (string) 
  (let (result)     
    (do* ((current string reststring)
	  (open (search "(" current) (search "(" current))
	  (colon (search ":" current) (search ":" current))
	  (close (search ")" current) (search ")" current))
	  (reststring (if close (subseq current (1+ close)) "")
		      (if close (subseq current (1+ close)) "")))
	((not colon) result)
      (if (and open colon close
	       (< open colon close))
	  (let ((liste (read-from-string
			(sem=make-nice-string
			 (subseq current open (1+ close))))))
	    (push (list (car liste)(rest liste)) result))))))

;;this should be working for the sem-omega version
(defun sem=read-models (strg) 
  (let (models)
    (do* ((current strg (subseq current (+ open 8)))
	  (open (search "(Model_" current) (search "(Model_" current)))
	((not open) models)
      (when 
	(push (read-from-string (subseq current open)) models)))))

(defun sem=make-nice-string (strg)
  (let ((charstoremove (list  #\: #\. #\,)))
    (substitute-if #\space #'(lambda (char)
			       (some #'(lambda (remove) (eq remove char))
				     charstoremove))
		   strg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Declarations for SEM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sem~vardecl (varlist sort)
  (mapcar #'(lambda (var)
	      (format nil "~A : ~A" var sort))
	  (if (consp varlist) varlist (list varlist))))

(defun sem~fundecl (constlist ransort &optional (domsort "") &key (special ""))
  (mapcar #'(lambda (var)
	      (format nil "~A : ~A -> ~A ~A" var domsort ransort special))
	  (if (consp constlist) constlist (list constlist))))
