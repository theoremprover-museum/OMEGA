(in-package :omega)

(defun thegoal (parameter)
  (let* ((goal (car parameter))
         (goalformula (node~formula
		       (agenda~task-node cri*current-task))))
    (if (stringp goal) ;; term is not bound:
	       (list (list (cons goal goalformula)))
      (data~equal goal goalformula))))

(defun positions-in-unquantified-form-of (parameter)
  (let ((form (first parameter)))
    (unless (or (logic~universal-quantification-p form)
		(logic~existential-quantification-p form))
      (let ((meta-formula (second parameter))
	    (meta-pos (third parameter)))
	(when (and meta-formula (not (stringp form)))
	  (let ((pos (data~substruct-positions meta-formula form :test #'(lambda
									   (term1 term2)
									   (my-string-matching term1 term2 (list (cons t t)))))))
	    (when pos
	      (mapcar #'(lambda (thepos)(list  (cons meta-pos thepos))) pos))))))))
	  


(defun my-string-matching (meta formula binding)
  (declare (edited  "27-MAR-1998")
	   (authors Jzimmer)
	   (input   "A 'meta' formula containing strings as meta-variables,"
		    "a formula and a binding (an alist).")
	   (effect  )
	   (value   "The binding of the strings (an alist), iff a matching"
		    "could be found."))
  
  (cond ((null meta) binding)
	((listp meta)
	 (cond ((and (term~appl-p formula)
		     (term~primitive-p (data~appl-function formula)))
		(cond ((stringp (first meta))
		       (my-string-matching (rest meta)
					    (data~appl-arguments formula)
					    (cons (cons (first meta)
							(data~appl-function formula))
						  binding)))
		      ((symbolp (first meta))
		       (let ((func (env~lookup-object (first meta)
						       (pds~environment cri*current-pds)))
			      (real-func (env~lookup-object (keim~name (data~appl-function formula))
							    (pds~environment cri*current-pds)))
			      )
			  (if func
			      (if (data~equal real-func func)
				  (my-string-matching (rest meta) (data~appl-arguments formula)
						       binding)
				nil)
			    nil)))
		      ((term~p (first meta))
		       (let ((func (first meta))
			      (real-func (env~lookup-object (keim~name (data~appl-function formula))
							    (pds~environment cri*current-pds)))
			      )
			      (if (data~equal real-func func)
				  (my-string-matching (rest meta) (data~appl-arguments formula)
						       binding)
				nil)))
		      (t nil)))
	       ((term~schema-p formula)
		(my-string-matching meta (data~schema-range) binding))
	       ((consp formula)
		(cond ((symbolp (first meta))
		       (let ((symbol (env~lookup-object (first meta)
							(pds~environment cri*current-pds)))
			     )
			 (if symbol
			     (if (data~equal (first formula)
					     symbol)
				 (my-string-matching (rest meta)
						     (rest formula)
						     binding)
			       nil)
			   nil)))
		      ((term~p (first meta))
		       (let ((symbol (first meta)))
			     (if (data~equal (first formula)
					     symbol)
				 (my-string-matching (rest meta)
						     (rest formula)
						     binding)
			       nil)))
		      ((stringp (first meta))
		       (my-string-matching (rest meta)
					    (rest formula)
					    (cons (cons (first meta)
							(first formula))
						  binding)))
		      (T (let ((matched (my-string-matching (first meta)
							     (first formula)
							     binding)))
			   (if matched 
			       (append (butlast matched)
				       (my-string-matching (rest meta)
							    (rest formula)
							    binding))
			     NIL)))))
	       (T NIL)))
	(T NIL)))



