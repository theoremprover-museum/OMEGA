;;; -*- syntax: common-lisp; package: omega; base: 10; mode: keim -*-

(in-package :omega)
(th~require-completely 'base)

(eval-when (compile)
           (error "This file should not be compiled."))



(dflt~defmatrix ande tactics	
   (agents (s-predicate (for Conjunction)
                        (uses )
			(level 1)
                        (definition (logic~conjunction-p Conjunction)))
           (s-predicate (for Conjunction)
                        (uses LConj)
			(level 1)
                        (definition (pred1 Conjunction LConj)))
           (s-predicate (for Conjunction)
                        (uses RConj)
			(level 1)
                        (definition (pred2 Conjunction RConj)))
           (s-predicate (for Conjunction)
                        (uses LConj RConj)
			(level 1)
                        (definition (and (pred1 Conjunction LConj)
                                         (pred2 Conjunction RConj))))
           (c-predicate (for RConj)
                        (uses Conjunction)
			(level 1)
                        (definition (pred2 Conjunction RConj)))
	   (c-predicate (for LConj)
                        (uses Conjunction)
			(level 1)
                        (definition (pred1 Conjunction LConj))
                        (help "Predicate for the left conjunct of a given conjunction.")))
   (predicates
    (pred1 (a1 a2)
	   (and (logic~conjunction-p a1)
                (data~equal a2 (first (data~appl-arguments a1)))))
    (pred2 (a1 a2)
	   (and (logic~conjunction-p a1)
                (data~equal a2 (second (data~appl-arguments a1)))))))


(dflt~defmatrix notnote tactics	
   (agents (s-predicate (for neg)
                        (uses )
			(level 1)
                        (definition (batac=double-negation-p neg)))
           (s-predicate (for neg)
                        (uses pos)
			(level 1)
                        (definition (data~equal (batac=introduce-double-negation pos) neg)))
           (c-predicate (for pos)
                        (uses neg)
			(level 1)
                        (definition (data~equal (batac=introduce-double-negation pos) neg)))))


(dflt~defmatrix notnoti tactics	
   (agents (c-predicate (for neg)
                        (uses )
			(level 1)
                        (definition (batac=double-negation-p neg)))
           (c-predicate (for neg)
                        (uses pos)
			(level 1)
                        (definition (data~equal (batac=introduce-double-negation pos) neg)))
           (s-predicate (for pos)
                        (uses neg)
			(level 1)
                        (definition (data~equal (batac=introduce-double-negation pos) neg)))))



(dflt~defmatrix pushneg tactics	
   (agents (s-predicate (for neg)
                        (uses )
			(level 1)
                        (definition (pred1 neg)))
           (s-predicate (for neg)
                        (uses pos)
			(level 1)
                        (definition (and (pred1 neg)             
					 (data~equal pos (pds~pushneg eg)))))
           (c-predicate (for pos)
                        (uses neg)
			(level 1)
                        (definition (and (pred1 neg)
					 (data~equal pos (pds~pushneg neg))))))
   (predicates
    (pred1 (neg) (and (logic~negation-p neg)
		      (not (logic~atom-p (car (data~appl-arguments neg))))))))
	   


(dflt~defmatrix pullneg tactics	
   (agents (c-predicate (for neg)
                        (uses )
			(level 1)
                        (definition (pred1 neg)))
           (c-predicate (for neg)
                        (uses pos)
			(level 1)
                        (definition (and (pred1 neg)
					 (data~equal pos (pds~pushneg neg)))))
           (s-predicate (for pos)
                        (uses neg)
			(level 1)
                        (definition (and (pred1 neg)
					 (data~equal pos (pds~pushneg neg))))))
   (predicates
    (pred1 (neg) (and (logic~negation-p neg)
		      (not (logic~atom-p (car (data~appl-arguments neg))))))))


(dflt~defmatrix ormp tactics	
   (agents (s-predicate (for disj)
                        (uses )
			(level 1)
                        (definition (pred1 disj)))
           (s-predicate (for disj)
                        (uses conc)
			(level 1)
                        (definition (pred2 disj conc)))
	   (s-predicate (for disj)
                        (uses conc neg)
			(level 1)
                        (definition (pred3 disj conc neg)))
	   (s-predicate (for neg)
                        (uses )
			(level 1)
                        (definition (pred4 neg)))
           (s-predicate (for neg)
                        (uses disj)
			(level 1)
                        (definition (pred5 disj neg)))
	   (s-predicate (for neg)
                        (uses disj conc)
			(level 1)
                        (definition (pred3 disj conc neg)))
	   (c-predicate (for conc)
                        (uses disj)
			(level 1)
                        (definition (pred2 disj conc)))
           (c-predicate (for conc)
                        (uses disj neg)
			(level 1)
                        (definition (pred3 disj conc neg))))
   (predicates
    (pred1 (disj) (logic~disjunction-p disj))
    (pred2 (disj conc) (and (pred1 disj)
			    (data~equal (cadr (data~appl-arguments disj))
					conc)))
    (pred3 (disj conc neg) (and (pred2 disj conc)
				(pred4 neg)
				(data~equal (car (data~appl-arguments disj))
					    (car (data~appl-arguments neg)))))
    (pred4 (neg) (logic~negation-p neg))
    (pred5 (disj neg) (and (pred1 disj)
			   (pred4 neg)
			   (data~equal (car (data~appl-arguments disj))
				       (car (data~appl-arguments neg)))))))    
    
		       

(dflt~defmatrix equivel tactics	
   (agents (s-predicate (for equiv)
                        (uses )
			(level 1)
                        (definition (pred1 equiv)))
           (s-predicate (for equiv)
                        (uses limp)
			(level 1)
                        (definition (pred2 equiv limp)))
           (c-predicate (for limp)
                        (uses )
			(level 1)
                        (definition (pred3 limp)))
	   (c-predicate (for limp)
                        (uses equiv)
			(level 1)
                        (definition (pred2 equiv limp))))
   (predicates
    (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (equiv limp) (and (pred1 equiv)
			     (pred3 limp)
			     (data~equal (batac=equivel-f-create equiv) limp)))
    (pred3 (limp) (logic~implication-p limp))))
    


(dflt~defmatrix equiver tactics	
   (agents (s-predicate (for equiv)
                        (uses )
			(level 1)
                        (definition (pred1 equiv)))
           (s-predicate (for equiv)
                        (uses rimp)
			(level 1)
                        (definition (pred2 equiv rimp)))
           (c-predicate (for rimp)
                        (uses )
			(level 1)
                        (definition (pred3 rimp)))
	   (c-predicate (for rimp)
                        (uses equiv)
			(level 1)
                        (definition (pred2 equiv rimp))))
   (predicates
    (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (equiv rimp) (and (pred1 equiv)
			     (pred3 rimp)
			     (data~equal (batac=equiver-f-create equiv) rimp)))
    (pred3 (rimp) (logic~implication-p rimp))))



(dflt~defmatrix equive tactics	
   (agents (s-predicate (for equiv)
                        (uses )
			(level 1)
                        (definition (pred1 equiv)))
           (s-predicate (for equiv)
                        (uses rimp)
			(level 1)
                        (definition (pred2 equiv rimp)))
	   (s-predicate (for equiv)
                        (uses limp)
			(level 1)
                        (definition (pred4 equiv limp)))
	   (s-predicate (for equiv)
                        (uses limp rimp)
			(level 1)
                        (definition (and (pred2 equiv rimp) (pred4 equiv limp))))
           (c-predicate (for rimp)
                        (uses )
			(level 1)
                        (definition (pred3 rimp)))
	   (c-predicate (for rimp)
                        (uses equiv)
			(level 1)
                        (definition (pred2 equiv rimp)))
	   (c-predicate (for rimp)
                        (uses limp)
			(level 1)
                        (definition (pred5 limp rimp)))
	   (c-predicate (for rimp)
                        (uses equiv limp)
			(level 1)
                        (definition (and (pred2  equiv rimp) (pred4 equiv limp))))
	   (c-predicate (for limp)
                        (uses )
			(level 1)
                        (definition (pred3 limp)))
	   (c-predicate (for limp)
                        (uses equiv)
			(level 1)
                        (definition (pred4 equiv limp)))
	   (c-predicate (for limp)
                        (uses rimp)
			(level 1)
                        (definition (pred5 limp rimp)))
	   (c-predicate (for limp)
                        (uses equiv rimp)
			(level 1)
                        (definition (and (pred2 equiv rimp) (pred4 equiv limp)))))
	   
   (predicates
    (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (equiv rimp) (and (pred1 equiv)
			     (pred3 rimp)
			     (data~equal (batac=equiver-f-create equiv) rimp)))
    (pred3 (imp) (logic~implication-p imp))
    (pred4 (equiv limp) (and (pred1 equiv)
			     (pred3 limp)
			     (data~equal (batac=equivel-f-create equiv) limp)))
    (pred5 (rimp limp) (batac=reversed-implications-p limp rimp))))



(dflt~defmatrix equivi tactics	
   (agents (c-predicate (for equiv)
                        (uses )
			(level 1)
                        (definition (pred1 equiv)))
           (c-predicate (for equiv)
                        (uses rimp)
			(level 1)
                        (definition (pred2 equiv rimp)))
	   (c-predicate (for equiv)
                        (uses limp)
			(level 1)
                        (definition (pred4 equiv limp)))
	   (c-predicate (for equiv)
                        (uses limp rimp)
			(level 1)
                        (definition (and (pred2 equiv rimp) (pred4 equiv limp))))
           (s-predicate (for rimp)
                        (uses )
			(level 1)
                        (definition (pred3 rimp)))
	   (s-predicate (for rimp)
                        (uses equiv)
			(level 1)
                        (definition (pred2 equiv rimp)))
	   (s-predicate (for rimp)
                        (uses limp)
			(level 1)
                        (definition (pred5 limp rimp)))
	   (s-predicate (for rimp)
                        (uses equiv limp)
			(level 1)
                        (definition (and (pred2  equiv rimp) (pred4 equiv limp))))
	   (s-predicate (for limp)
                        (uses )
			(level 1)
                        (definition (pred3 limp)))
	   (s-predicate (for limp)
                        (uses equiv)
			(level 1)
                        (definition (pred4 equiv limp)))
	   (s-predicate (for limp)
                        (uses rimp)
			(level 1)
                        (definition (pred5 limp rimp)))
	   (s-predicate (for limp)
                        (uses equiv rimp)
			(level 1)
                        (definition (and (pred2 equiv rimp) (pred4 equiv limp)))))
	   
   (predicates
    (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (equiv rimp) (and (pred1 equiv)
			     (pred3 rimp)
			     (data~equal (batac=equiver-f-create equiv) rimp)))
    (pred3 (imp) (logic~implication-p imp))
    (pred4 (equiv limp) (and (pred1 equiv)
			     (pred3 limp)
			     (data~equal (batac=equivel-f-create equiv) limp)))
    (pred5 (rimp limp) (batac=reversed-implications-p limp rimp))))




(defun batac=compute-foralle-instance (formula term-list)
  (let ((new-term formula))
    (dolist (x term-list)
      (when (logic~universal-quantification-p new-term)
	(setq new-term (beta~contract
			(term~appl-create (car (data~appl-arguments new-term))
					  (list x))))))
    new-term))

(defun batac=compute-foralle-termlist (all-formula formula &optional reversed-varlist)
  (multiple-value-bind (ok subst)
      (term~alpha-match all-formula formula)
    (if ok (mapcar #'(lambda (x) (subst-apply subst x))
		   (reverse reversed-varlist))
      (when (logic~universal-quantification-p all-formula)
	(batac=compute-foralle-termlist
	 (logic~quantification-scope all-formula)
	 formula
	 (cons (logic~quantification-bound-variable all-formual) reversed-varlist))))))


(dflt~defmatrix foralle* tactics
   (agents (s-predicate (for univline)
                        (uses )
			(level 1)
                        (definition (pred0 univline)))
           (s-predicate (for univline)
                        (uses elimline)
			(level 20)
                        (definition (pred1 univline elimline)))
           (s-predicate (for univline)
                        (uses elimline terms)
			(level 1)
                        (definition (pred2 univline elimline (:param terms))))
           (c-predicate (for elimline)
                        (uses univline)
			(level 20)
                        (definition (pred1 univline elimline)))
	   (c-predicate (for elimline)
                        (uses univline terms)
			(level 20)
                        (definition (pred2 univline elimline (:param terms))))
	   (function    (for terms)
                        (uses elimline)
			(level 3)
                        (definition (func1 elimline))) ;; alle Konstanten suchen
	   (function    (for terms)
                        (uses univline)
			(level 20)
                        (definition (func2 univline))) ;; neue Konstanten vorschlagen
	   (function    (for terms)
                        (uses univline elimline)
			(level 3)
                        (definition (batac=compute-foralle-termlist univline elimline)))) ;; exakte Terme berechnen
   (predicates
    (pred0 (univline) (logic~universal-quantification-p univline))
    (pred1 (univline elimline)
	   (and (pred0 univline)
		(find-if #'(lambda (:protect x)
			     (term~alpha-match x elimline))
			 (mapcar #'(lambda (:protect pos)
				     (data~struct-at-position univline pos))
				 (data~positions univline
						 #'(lambda (:protect x)
						     (type~o-p (term~type x))))))))
    (pred2 (univline elimline terms)
	   (and (pred0 univline)
		(data~equal (batac=compute-foralle-instance univline terms) elimline)))

    (func1 (line)
	   (mapcar #'(lambda (:protect pos)
		       (data~struct-at-position elimline pos))
		   (data~positions elimline #'term~constant-p)))
    (func2 (univline)
	   (when (pred0 univline)
	     (mapcar
	      #'(lambda (:protect var)
		  (term~generate-term-primitive-with-new-name 'a (term~type var)
						  'term+constant
						  (pds~environment omega*current-proof-plan)))
	      (orules=strip-quantors2 univline))))))



(dflt~defmatrix foralli* tactics
   (agents (c-predicate (for univline)
                        (uses )
			(level 1)
                        (definition (pred0 univline)))
           (c-predicate (for univline)
                        (uses line)
			(level 20)
                        (definition (pred1 univline line)))
           (c-predicate (for univline)
                        (uses line newconsts)
			(level 1)
                        (definition (pred2 univline line (:param newconsts))))
           (s-predicate (for line)
                        (uses univline)
			(level 20)
                        (definition (pred1 univline line)))
	   (s-predicate (for line)
                        (uses univline newconsts)
			(level 1)
                        (definition (pred2 univline line (:param newconsts))))
	   (function    (for newconsts)
                        (uses line)
			(level 3)
                        (definition (func1 line))) ;; alle Konstanten suchen
	   (function    (for newconsts)
                        (uses univline)
			(level 3)
                        (definition (func2 univline))) ;; neue Konstanten vorschlagen
	   (function    (for newconsts)
                        (uses univline line)
			(level 3)
                        (definition (batac=compute-foralle-termlist univline line)))) ;; exakte Konstante berechnen
   (predicates
    (pred0 (univline) (logic~universal-quantification-p univline))
    (pred1 (univline line)
	   (and (pred0 univline)
		(find-if #'(lambda (:protect x)
			     (term~alpha-match x line))
			 (mapcar #'(lambda (:protect pos)
				     (data~struct-at-position univline pos))
				 (data~positions univline
						 #'(lambda (:protect x)
						     (type~o-p (term~type x)))))))) 
    (pred2 (univline line newconsts)
	   (and (pred0 univline)
		(data~equal (batac=compute-foralle-instance univline newconsts) line)))

    (func1 (line)
	   (mapcar #'(lambda (:protect pos)
		       (data~struct-at-position line pos))
		   (data~positions line #'term~constant-p)))
    (func2 (univline)
	   (when (pred0 univline)
	     (mapcar
	      #'(lambda (:protect var)
		  (term~generate-term-primitive-with-new-name 'a (term~type var)
						  'term+constant
						  (pds~environment omega*current-proof-plan)))
	      (orules=strip-quantors2 univline))))))


(dflt~defmatrix =ref tactics	
   (agents (c-predicate (for equality-line)
                        (uses )
                        (definition (logic~equality-p equality-line)))
           (c-predicate (for equality-line)
                        (uses term)
                        (definition (and (logic~equality-p equality-line)
					 (data~equal (car (data~appl-arguments
							   equality-line))
						     term))))
           (function    (for term)
                        (uses equality-line)
                        (definition (when (logic~equality-p equality-line)
				      (when (data~equal (car (data~appl-arguments
							      equality-line))
							(cadr (data~appl-arguments
							      equality-line)))
					(car (data~appl-arguments
							      equality-line))))))))




(dflt~defmatrix =sym tactics	
   (agents (c-predicate (for equality-line1)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line1)))
           (s-predicate (for equality-line2)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line2)))
	   (c-predicate (for equality-line1)
                        (uses equality-line2)
			(level 1)
                        (definition (pred2 equality-line1 equality-line2)))
	   (s-predicate (for equality-line2)
                        (uses equality-line1)
			(level 1)
                        (definition (pred2 equality-line1 equality-line2))))
   (predicates
    (pred1 (eql) (logic~equality-p eql))
    (pred2 (eql1 eql2) (and (logic~equality-p eql1)
			    (logic~equality-p eql2)
			    (data~equal (batac=equality-sym-create eql1) eql2)))))



(dflt~defmatrix =trans tactics	
   (agents (c-predicate (for equality-line1)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line1)))
	   (c-predicate (for equality-line1)
                        (uses equality-line2)
			(level 1)
                        (definition (pred2 equality-line1 equality-line2)))
	   (c-predicate (for equality-line1)
                        (uses equality-line2  equality-line3)
			(level 1)
                        (definition (pred3 equality-line1 equality-line2  equality-line3)))
	   (s-predicate (for equality-line2)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line2)))
	   (s-predicate (for equality-line2)
                        (uses equality-line1)
			(level 1)
                        (definition (pred2 equality-line1 equality-line2)))
           (s-predicate (for equality-line2)
                        (uses equality-line1 equality-line3)
			(level 1)
                        (definition (pred3 equality-line1 equality-line2  equality-line3)))
	   (s-predicate (for equality-line3)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line3)))
	   (s-predicate (for equality-line3)
                        (uses equality-line1)
			(level 1)
                        (definition (pred2 equality-line1 equality-line3)))
           (s-predicate (for equality-line3)
                        (uses equality-line1 equality-line2)
			(level 1)
                        (definition (pred3 equality-line1 equality-line2  equality-line3))))
   (predicates
    (pred1 (eql) (logic~equality-p eql))
    (pred2 (eql1 eql2) (and (logic~equality-p eql1)
			    (logic~equality-p eql2)
			    (or
			     (data~equal (first (data~appl-arguments eql1)) (first (data~appl-arguments eql2)))
			     (data~equal (second (data~appl-arguments eql1)) (first (data~appl-arguments eql2)))	 
			     (data~equal (first (data~appl-arguments eql1)) (second (data~appl-arguments eql2)))
			     (data~equal (second (data~appl-arguments eql1)) (second
									      (data~appl-arguments eql2))))))
    (pred3 (eql1 eql2 eql3) (and (logic~equality-p eql1)
				 (logic~equality-p eql2)
				 (logic~equality-p eql3)
				 (data~equal (batac=equality-trans-create eql2 eql3) eql1)))))




(dflt~defmatrix =subst tactics	
   (agents (s-predicate (for equality-line)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line)))
	   (s-predicate (for equality-line)
                        (uses line1)
			(level 3)
                        (definition (pred2 equality-line line1)))
	   (s-predicate (for equality-line)
                        (uses line2)
			(level 3)
                        (definition (pred2 equality-line line2)))
	   (s-predicate (for equality-line)
                        (uses line1 line2)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (s-predicate (for equality-line)
                        (uses line1 line2 position)
			(level 10)
                        (definition (pred4 equality-line line1 line2 (:param position))))
	   (s-predicate (for equality-line)
                        (uses line1 position)
			(level 3)
                        (definition (pred5 equality-line line1 (:param position))))
	   (s-predicate (for equality-line)
                        (uses line2 position)
			(level 3)
                        (definition (pred5 equality-line line2 (:param position))))

	   (c-predicate (for line1)
			(uses )
			(level 20)
			(definition (pred8 line1)))
	   (c-predicate (for line1)
                        (uses equality-line)
			(level 3)
                        (definition (pred2 equality-line line1)))
	   (c-predicate (for line1)
                        (uses line2)
			(level 20)
                        (definition (pred7 line1 line2)))
	   (c-predicate (for line1)
                        (uses position)
			(level 2)
                        (definition (pred0 line1 (:param position))))
	   (c-predicate (for line1)
                        (uses equality-line line2)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (c-predicate (for line1)
                        (uses equality-line position)
			(level 3)
                        (definition (pred5 equality-line line1 (:param position))))
	   (c-predicate (for line1)
                        (uses line2 position)
			(level 10)
                        (definition (pred6 line1 line2 position)))
	   (c-predicate (for line1)
                        (uses equality-line line2 position)
			(level 10)
                        (definition (pred4 equality-line line1 line2 (:param position))))
	   
	   (s-predicate (for line2)
			(uses )
			(level 20)
			(definition (pred9 line2)))
	   (s-predicate (for line2)
                        (uses equality-line)
			(level 3)
                        (definition (pred2 equality-line line2)))
	   (s-predicate (for line2)
                        (uses line1)
			(level 20)
                        (definition (pred7 line1 line2)))
	   (s-predicate (for line2)
                        (uses position)
			(level 2)
                        (definition (pred0 line2 (:param position))))
	   (s-predicate (for line2)
                        (uses equality-line line1)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (s-predicate (for line2)
                        (uses equality-line position)
			(level 3)
                        (definition (pred5 equality-line line2 (:param position))))
	   (s-predicate (for line2)
                        (uses line1 position)
			(level 10)
                        (definition (pred6 line1 line2 position)))
	   (s-predicate (for line2)
                        (uses equality-line line1 position)
			(level 10)
                        (definition (pred4 equality-line line1 line2 (:param position))))

	   (function    (for position)
			(uses equality-line line1)
			(level 3)
			(definition (func0 equality-line line1)))
	   (function    (for position)
			(uses equality-line line2)
			(level 3)
			(definition (func0 equality-line line2)))
	   (function    (for position)
			(uses line1 line2)
			(level 20)
			(definition (pred7 line1 line2)))
	   (function    (for position)
			(uses equality-line line1 line2)
			(level 10)
			(definition (pred3 equality-line line1 line2))))
   
   (predicates
    (pred0 (line position)
	   (find position (data~positions line #'term~p) :test #'keim~equal))
    (pred1 (eql)
	   (logic~equality-p eql))
    (pred2 (eql line)  (and (pred1 eql) (func0 eql line)))
    (pred3 (equality-line line1 line2)
	   (when (pred1 equality-line)
	     (find-if #'(lambda (:protect x)
			  (term~alpha-equal
			   (batac=equality-subst-create-f line2 equality-line x) 
			   x))
		      (func0 equality-line line1))))
    (pred4 (equality-line line1 line2 position)
	   (and (pred1  equality-line)
		(find position (func0  equality-line line1) :test #'keim~equal)
		(term~alpha-equal (batac=equality-subst-create-f line2 equality-line position)
				  line1)))
    (pred5 (equality-line line1 position)
	   (find position (func0  equality-line line1) :test #'keim~equal))
    (pred6 (line1 line2 position)
	   (and (pred0 line1 position)
		(pred0 line2 position)
		(pred4 (batac=equality-subst-create-l line1 line2 position)
		       line1 line2 position)))
    (pred7 (line1 line2)
	   (find-if #'(lambda (:protect x) (pred6 line1 line2 x))
		    (union (data~positions line1 #'term~p) (data~positions line2 #'term~p))))
    (pred8 (line1)
	   (find-if #'(lambda (:protect x) (pred7 line1 (node~formula x)))
		    (pds~node-supports (:node line1))))
    (pred9 (line2)
	   (find-if #'(lambda (:protect x) (pred7 line2 (node~formula x)))
		    (pds~open-nodes omega*current-proof-plan)))
    (func0 (eql line)
	   (when (pred1 eql)
	     (data~positions line #'(lambda (:protect x)
				      (or (data~equal (first (data~appl-arguments eql)) x)
					  (data~equal (second (data~appl-arguments eql)) x))))))))
    

		
;(com~defcommand neg=i
;  (argnames unequation line1 line2 position)
;  (argtypes ndline ndline ndline position)
;  (arghelps "An unequation" "A line." "A negated line." "A position.")
;  (function batac=neg=i)
;  (frag-cats tactics base)
;  (defaults ((oc~default-current-planline) (com~unspecified) (com~unspecified) (com~unspecified)))
;  (log-p T)
;  (help "Negated equality Introduction."))




(dflt~defmatrix neg=sym tactics	
   (agents (c-predicate (for ineguality-line1)
                        (uses )
			(level 1)
                        (definition (pred1 ineguality-line1)))
           (s-predicate (for ineguality-line2)
                        (uses )
			(level 1)
                        (definition (pred1 ineguality-line2)))
	   (c-predicate (for ineguality-line1)
                        (uses ineguality-line2)
			(level 1)
                        (definition (pred2 ineguality-line1 ineguality-line2)))
	   (s-predicate (for ineguality-line2)
                        (uses ineguality-line1)
			(level 1)
                        (definition (pred2 ineguality-line1 ineguality-line2))))
   (predicates
    (pred1 (neql) (and (logic~negation-p neql)
		       (logic~equality-p (car (data~appl-arguments neql)))))
    (pred2 (neql1 neql2) (and (pred1 neql1)
			      (pred1 neql2)
			      (data~equal (batac=ineguality-sym-create-f neql1) neql2)))))


(dflt~defmatrix imp2or tactics	
   (agents (s-predicate (for implication-line)
                        (uses )
			(level 1)
                        (definition (pred1 implication-line)))
	   (s-predicate (for implication-line)
                        (uses or-line)
			(level 1)
                        (definition (batac=imp2or-a-p implication-line or-line)))
	   (c-predicate (for or-line)
                        (uses )
			(level 1)
                        (definition (pred2 or-line)))
	   (c-predicate (for or-line)
                        (uses implication-line)
			(level 1)
                        (definition (batac=imp2or-a-p implication-line or-line))))
   (predicates
    (pred1 (impl) (logic~implication-p impl))
    (pred2 (disj) (logic~disjunction-p disj))))


;(com~defcommand indirect
;  (argnames form false)
;  (argtypes ndline ndline)
;  (arghelps "Conclusion line" "Line with False")
;  (function batac=indirect)
;  (frag-cats tactics base)
;  (defaults batac=indirect-defaults)
;  (log-p T)
;  (help "Alternative not-elimination."))


(dflt~defmatrix modtoll tactics
   (agents (s-predicate (for aimpb)
                        (uses )
			(level 1)
                        (definition (logic~implication-p aimpb)))
           (s-predicate (for aimpb)
                        (uses negb)
			(level 1)
                        (definition (pred2 aimpb negb)))
           (s-predicate (for aimpb)
                        (uses nega)
			(level 1)
                        (definition (pred1 aimpb nega)))
           (s-predicate (for aimpb)
                        (uses negb nega)
			(level 1)
                        (definition (and (pred2 aimpb negb)
                                         (pred1 aimpb nega))))
           (c-predicate (for nega)
                        (uses aimpb)
			(level 1)
                        (definition (pred1 aimpb nega)))
	   (s-predicate (for negb)
                        (uses aimpb)
			(level 1)
                        (definition (pred2 aimpb negb))))
   (predicates
    (pred1 (a1 a2)
	   (and (logic~implication-p a1)
                (data~equal a2 (logic~negate (first (data~appl-arguments a1))))))
    (pred2 (a1 a2)
	   (and (logic~implication-p a1)
                (data~equal a2 (logic~negate (second (data~appl-arguments a1))))))))


(dflt~defmatrix beta-normalize tactics
   (agents (c-predicate (for line1)
                        (uses line2)
			(level 3)
                        (definition (data~equal (beta~normalize line2) line1)))
	   (s-predicate (for line2)
                        (uses )
			(level 3)
                        (definition (not (beta~normform-p line2))))
           (s-predicate (for line2)
                        (uses line1)
			(level 3)
                        (definition (data~equal (beta~normalize line2) line1)))))


(dflt~defmatrix beta-expand tactics
   (agents (c-predicate (for line1)
                        (uses )
			(level 3)
                        (definition (not (beta~normform-p line1))))
           (c-predicate (for line1)
                        (uses line2)
			(level 3)
                        (definition (pred1 line1 line2)))
	   (c-predicate (for line1)
                        (uses line2 positions)
			(level 3)
                        (definition (pred2 line1 line2 (:param positions))))
           (s-predicate (for line2)
                        (uses line1)
			(level 3)
                        (definition (pred1 line1 line2)))
	   (s-predicate (for line2)
                        (uses line1 positions)
			(level 3)
                        (definition (pred2 line1 line2 (:param positions))))
;           (function (for positions)
;                        (uses line1 line2)
;                        (definition (func line1 line2)))
	   )
   (predicates 
    (pred1 (line1 line2) (lam~equal-p line1 line2))
    (pred2 (line1 line2 position) (data~equal (beta~expand line2 positions) line1)) 
    ))
   
	   

(dflt~defmatrix contrapos tactics
   (agents (c-predicate (for conc)
                        (uses )
			(level 1)
                        (definition (logic~implication-p conc)))
           (c-predicate (for conc)
                        (uses line2)
			(level 1)
                        (definition (pred1 conc line2)))
	   (s-predicate (for line2)
                        (uses )
			(level 1)
                        (definition (logic~implication-p line2)))
           (s-predicate (for line2)
                        (uses conc)
			(level 1)
                        (definition (pred1 conc line2))))
   (predicates
    (pred1 (conc line2) (and (logic~implication-p conc)
			     (data~equal (batac=contrapos-f line2) conc)))))
    


;(com~defcommand modbarbara
;  (argnames conc line2 line3)
;  (argtypes ndline ndline ndline)
;  (arghelps "An implication line"
;            "Another one with the same antecedent"
;            "One with the same succedent as the first")
;  (function batac=modbarbara)
;  (frag-cats tactics base)
;  (defaults ((oc~default-current-planline) (com~unspecified) (com~unspecified)))
;  (log-p T)
;  (help "Transitivity of implication: modus barbara."))



(dflt~defmatrix or2imp tactics	
   (agents (c-predicate (for implication-line)
                        (uses )
			(level 1)
                        (definition (pred1 implication-line)))
	   (c-predicate (for implication-line)
                        (uses or-line)
			(level 1)
                        (definition (batac=imp2or-a-p implication-line or-line)))
	   (s-predicate (for or-line)
                        (uses )
			(level 1)
                        (definition (pred2 or-line)))
	   (s-predicate (for or-line)
                        (uses implication-line)
			(level 1)
                        (definition (batac=imp2or-a-p implication-line or-line))))
   (predicates
    (pred1 (impl) (logic~implication-p impl))
    (pred2 (disj) (logic~disjunction-p disj))))


;(com~defcommand that 
;  (argnames that-line)
;  (argtypes ndline)
;  (arghelps "A line with a description operator.")
;  (function batac=that)
;  (frag-cats tactics base)
;  (defaults ((com~unspecified))) 
;  (log-p T)
;  (help "Eliminating the first description operator THAT"))



(dflt~defmatrix equivsubst tactics	
   (agents (s-predicate (for equality-line)
                        (uses )
			(level 1)
                        (definition (pred1 equality-line)))
	   (s-predicate (for equality-line)
                        (uses line1)
			(level 3)
                        (definition (pred2 equality-line line1)))
	   (s-predicate (for equality-line)
                        (uses line2)
			(level 3)
                        (definition (pred2 equality-line line2)))
	   (s-predicate (for equality-line)
                        (uses line1 line2)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (s-predicate (for equality-line)
                        (uses line1 line2 position)
			(level 10)
                        (definition (pred4 equality-line line1 line2 (:param position))))
	   (s-predicate (for equality-line)
                        (uses line1 position)
			(level 3)
                        (definition (pred5 equality-line line1 (:param position))))
	   (s-predicate (for equality-line)
                        (uses line2 position)
			(level 3)
                        (definition (pred5 equality-line line2 (:param position))))

	   (c-predicate (for line1)
                        (uses equality-line)
			(level 3)
                        (definition (pred2 equality-line line1)))
	   (c-predicate (for line1)
                        (uses line2)
			(level 20)
                        (definition (pred7 line1 line2)))
	   (c-predicate (for line1)
                        (uses position)
			(level 2)
                        (definition (pred0 line1 (:param position))))
	   (c-predicate (for line1)
                        (uses equality-line line2)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (c-predicate (for line1)
                        (uses equality-line position)
			(level 3)
                        (definition (pred5 equality-line line1 (:param position))))
	   (c-predicate (for line1)
                        (uses line2 position)
			(level 10)
                        (definition (pred6 line1 line2 position)))
	   (c-predicate (for line1)
			(level 10)
                        (uses equality-line line2 position)
                        (definition (pred4 equality-line line1 line2 (:param position))))

	   (s-predicate (for line2)
                        (uses equality-line)
			(level 3)
                        (definition (pred2 equality-line line2)))
	   (s-predicate (for line2)
                        (uses line1)
			(level 20)
                        (definition (pred7 line1 line2)))
	   (s-predicate (for line2)
                        (uses position)
			(level 2)
                        (definition (pred0 line2 (:param position))))
	   (s-predicate (for line2)
                        (uses equality-line line1)
			(level 10)
                        (definition (pred3 equality-line line1 line2)))
	   (s-predicate (for line2)
                        (uses equality-line position)
			(level 3)
                        (definition (pred5 equality-line line2 (:param position))))
	   (s-predicate (for line2)
                        (uses line1 position)
			(level 10)
                        (definition (pred6 line1 line2 (:param position))))
	   (s-predicate (for line2)
                        (uses equality-line line1 position)
			(level 10)
                        (definition (pred4 equality-line line1 line2 (:param position))))

	   (function    (for position)
			(uses equality-line line1)
			(level 3)
			(definition (func0 equality-line line1)))
	   (function    (for position)
			(uses equality-line line2)
			(level 3)
			(definition (func0 equality-line line2)))
	   (function    (for position)
			(uses line1 line2)
			(level 20)
			(definition (car (pred7 line1 line2))))
	   (function    (for position)
			(uses equality-line line1 line2)
			(level 10)
			(definition (pred3 equality-line line1 line2))))
   
   (predicates
    (pred0 (line position) (find position (data~positions line #'term~p) :test #'keim~equal))
    (pred1 (eql) (logic~implication-p eql))
    (pred2 (eql line)  (and (pred1 eql) (func0 eql line)))
    (pred3 (equality-line line1 line2)
	   (when (pred1 equality-line)
	     (find-if #'(lambda (:protect x)
			  (term~alpha-equal
			   (batac=equivsubst-create-f line2 equality-line x) 
			   x))
		      (func0 equality-line line1))))
    (pred4 (equality-line line1 line2 position)
	   (and (pred1 equality-line)
	        (find position (func0 equality-line line1) :test #'keim~equal)
		(term~alpha-equal (batac=equivsubst-create-f line2 equality-line position)
				  line1)))
    (pred5 (equality-line line1 position)
	   (find position (func0 equality-line line1) :test #'keim~equal))
    (pred6 (line1 line2 position)
	   (and (pred0 line1 position)
		(pred0 line2 position)
		(pred4 
		 (batac=equivsubst-create-l line1 line2 position)
		 line1 line2 position)))
    (pred7 (line1 line2)
	   (some #'(lambda (:protect x) (pred6 line1 line2 x))
		 (union (data~positions line1 #'term~p) (data~positions line2 #'term~p))))
    (func0 (eql line)
	   (when (pred1 eql)
	     (data~positions line #'(lambda (:protect x)
				      (or (data~equal (first (data~appl-arguments eql)) x)
					  (data~equal (second (data~appl-arguments eql)) x))))))))


(dflt~defmatrix =2equiv tactics
   (agents (s-predicate (for equality)
                        (uses )
			(level 3)
                        (definition (func1 equality)))
	   (s-predicate (for equality)
                        (uses equivalence)
			(level 3)
                        (definition (func3 equality equivalence)))
	   (s-predicate (for equality)
                        (uses position)
			(level 3)
                        (definition (find (:param position) (func1 equality))))
	   (s-predicate (for equality)
                        (uses equivalence position)
			(level 3)
                        (definition (and (pred3 equality equivalence)
					 (batac==2equiv-applicable-p equality equivalence
								     (:param position)))))
	   (c-predicate (for equivalence)
                        (uses )
			(level 3)
                        (definition (func2 equivalence)))
	   (c-predicate (for equivalence)
                        (uses equality)
			(level 3)
                        (definition (func3 equality equivalence)))
	   (c-predicate (for equivalence)
                        (uses position)
			(level 3)
                        (definition (find (:param position) (func2 equivalence))))
	   (c-predicate (for equivalence)
                        (uses equality position)
			(level 3)
                        (definition (and (pred3 equality equivalence)
					 (batac==2equiv-applicable-p equality equivalence
								     (:param position)))))
	   (function    (for position)
                        (uses equality)
			(level 3)
                        (definition (car (func1 equality))))
	   (function    (for position)
                        (uses equivalence)
			(level 3)
                        (definition (car (func2 equivalence))))
	   (function    (for position)
                        (uses equality equivalence)
			(level 3)
                        (definition (func3 equality equivalence)))

	   )
   (predicates
    (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (eq) (logic~equality-p eq))
    (pred3 (eq equiv) (and (pred1 equiv) (pred2 eq)))
    (func1 (eq) (when (pred2 eq) (data~positions eq #'(lambda (:protect x) (logic~equality-p x)))))
    (func2 (equiv) (when (pred1 equiv) (data~positions equiv #'(lambda (:protect x) (logic~equivalence-p x)))))
    (func3 (equality equiv) (when (pred3 equality equiv)
			      (find-if #'(lambda (:protect pos)
					   (batac==2equiv-applicable-p equality equiv pos))
				       (func2 equiv))))
   ))


(dflt~defmatrix equiv2= tactics
   (agents (c-predicate (for equality)
                        (uses )
			(level 3)
                        (definition (func1 equality)))
	   (c-predicate (for equality)
                        (uses equivalence)
			(level 3)
                        (definition (func3 equality equivalence)))
	   (c-predicate (for equality)
                        (uses pos)
			(level 3)
                        (definition (find pos (func1 equality) :test #'keim~equal)))
	   (c-predicate (for equality)
                        (uses equivalence pos)
			(level 3)
                        (definition (and (pred3 equality equivalence)
					 (batac==2equiv-applicable-p equality equivalence
								     (:param pos)))))
	   (s-predicate (for equivalence)
                        (uses )
			(level 3)
                        (definition (func2 equivalence)))
	   (s-predicate (for equivalence)
                        (uses equality)
			(level 3)
                        (definition (func3 equality equivalence)))
	   (s-predicate (for equivalence)
                        (uses pos)
			(level 3)
                        (definition (find pos (func2 equivalence) :test #'keim~equal)))
	   (s-predicate (for equivalence)
                        (uses equality pos)
			(level 3)
                        (definition (and (pred3 equality equivalence)
					 (batac==2equiv-applicable-p equality equivalence
								     (:param pos)))))
	   (function    (for pos)
                        (uses equality)
			(level 3)
                        (definition (car (func1 equality))))
	   (function    (for pos)
                        (uses equivalence)
			(level 3)
                        (definition (car (func2 equivalence))))
	   (function    (for pos)
                        (uses equality equivalence)
			(level 3)
                        (definition (func3 equality equivalence)))

	   )
   (predicates
        (pred1 (equiv) (logic~equivalence-p equiv))
    (pred2 (eq) (logic~equality-p eq))
    (pred3 (eq equiv) (and (pred1 equiv) (pred2 eq)))
    (func1 (eq) (when (pred2 eq) (data~positions eq #'(lambda (:protect x) (logic~equality-p x)))))
    (func2 (equiv) (when (pred1 equiv) (data~positions equiv #'(lambda (:protect x) (logic~equivalence-p x)))))
    (func3 (equality equiv) (when (pred3 equality equiv)
			      (find-if #'(lambda (:protect pos)
					   (batac==2equiv-applicable-p equality equiv pos))
				       (func2 equiv))))
   ))


;(com~defcommand LR2equiv
;  (argnames Leftterm rightterm equivalence)
;  (argtypes ndline ndline ndline)
;  (arghelps "A line with leftside of equivalence" "A line with rightside of equivalence"
;            "A line with equivalence")
;  (function batac=LR2equiv)
;  (frag-cats tactics base)
;  (log-p T)
;  (help "Transforms equality on truth-values into equivalence of truth-values."))


(dflt~defmatrix idemor tactics	
   (agents (c-predicate (for disjunction)
                        (uses )
			(level 1)
                        (definition (func disjunction)))
	   (c-predicate (for disjunction)
                        (uses merge)
			(level 1)
                        (definition (and (func disjunction)
					 (data~equal merge (func disjunction)))))
	   (s-predicate (for merge)
                        (uses disjunction)
			(level 1)
                        (definition (and (func disjunction)
					 (data~equal merge (func disjunction))))))
   (predicates
    (func (disj) (when (and (logic~disjunction-p disj)
			    (data~equal (car (data~appl-arguments disj))
					(cadr (data~appl-arguments disj))))
		   (car (data~appl-arguments disj))))))


(dflt~defmatrix defse tactics	
   (agents (c-predicate (for concl)
                        (uses )
			(level 20)
                        (definition (not (orules=contained-definition concl))))
	   (c-predicate (for concl)
                        (uses line2)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     concl line2 (func1 concl))))
	   (c-predicate (for concl)
                        (uses line2 defs)
			(level 20)
                        (definition  (gentac=substituted-definitions-p
				     concl line2 (:param defs))))
	   (s-predicate (for line2)
                        (uses )
			(level 20)
                        (definition (orules=contained-definition line2)))
	   (s-predicate (for line2)
                        (uses concl)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     concl line2 (func1 concl))))
	   (s-predicate (for line2)
                        (uses concl defs)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     concl line2 (:param defs))))
	   (function    (for defs)
			(uses)
			(level 20)
			(definition (list '=)))
	   (function    (for defs)
			(uses concl)
			(level 20)
			(definition (cons '= (func1 concl))))
	   (function    (for defs)
			(uses concl line2)
			(level 20)
			(definition (if  (gentac=substituted-definitions-p
					  concl line2 (func1 concl))
					(cons '= (func1 concl))
				      (list '=)))))
   (predicates
    (func0 (line) (data~positions
		    line
		    #'(lambda (:protect x)
			(and (term~constant-p x)
			     (th~find-assumption (keim~name x) (prob~theory
								omega*current-proof-plan))))))
    (func1 (line) (mapcar #'(lambda (:protect x)
			      (and (term~constant-p x)
				   (th~find-assumption (keim~name x) (prob~theory
								      omega*current-proof-plan)))
			   (func0 line))))))



(dflt~defmatrix defsi tactics	
   (agents (c-predicate (for concl)
                        (uses )
			(level 20)
                        (definition (orules=contained-definition concl)))
	   (c-predicate (for concl)
                        (uses line2)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     line2 concl (func1 line2))))
	   (c-predicate (for concl)
                        (uses line2 defs)
			(level 20)
                        (definition  (gentac=substituted-definitions-p
				      line2 concl (:param defs))))
	   (s-predicate (for line2)
                        (uses )
			(level 20)
                        (definition (not (orules=contained-definition line2))))
	   (s-predicate (for line2)
                        (uses concl)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     line2 concl (func1 line2))))
	   (s-predicate (for line2)
                        (uses concl defs)
			(level 20)
                        (definition (gentac=substituted-definitions-p
				     concl line2 (:param defs))))
	   (function    (for defs)
			(uses)
			(level 20)
			(definition (list '=)))
	   (function    (for defs)
			(uses line2)
			(level 20)
			(definition (cons '= (func1 line2))))
	   (function    (for defs)
			(uses concl line2)
			(level 20)
			(definition (if (gentac=substituted-definitions-p
					   line2 concl (func1 line2))
					(cons '= (func1 line2))
				      (list '=)))))
   (predicates
    (func0 (line) (data~positions
		    line
		    #'(lambda (:protect x)
			(and (term~constant-p x)
			     (th~find-assumption (keim~name x) (prob~theory
								omega*current-proof-plan))))))
    (func1 (line) (mapcar #'(lambda (:protect x)
			      (and (term~constant-p x)
				   (th~find-assumption (keim~name x) (prob~theory
								      omega*current-proof-plan)))
			      (func0 line))))))



(dflt~defmatrix simplify tactics	
   (agents (c-predicate (for concl)
                        (uses line2)
			(level 10)
                        (definition (batac=simplified-p concl line2)))
	   (s-predicate (for concl)
                        (uses line2)
			(level 10)
                        (definition (batac=simplified-p concl line2)))))


(dflt~defmatrix simplify-goal tactics	
   (agents (c-predicate (for concl)
                        (uses line2)
			(level 10)
                        (definition (batac=simplified-p line2 concl)))
	   
	   (s-predicate (for concl)
                        (uses line2)
			(level 10)
                        (definition (batac=simplified-p line2 concl)))))


(dflt~defmatrix defn-expand* tactics
   (agents (s-predicate (for line)
                        (uses )
			(level 3)
                        (definition (orules=contained-definition line)))
           (s-predicate (for line)
                        (uses definition)
			(level 10)
                        (definition (pred1 line (:param definition))))
	   (s-predicate (for line)
			(level 5)
                        (uses definition position-list)
                        (definition (pred2 line (:param definition) (:param position-list))))
	   (function (for definition)
		     (uses line)
		     (level 3)
		     (definition (orules=contained-definition line)))
           (function (for definition)
		     (uses line position-list)
		     (level 20)
		     (definition (func1 line (:param position-list))))
	   (function (for position-list)
		     (uses line)
		     (level 3)
		     (definition (data~substruct-positions (orules=contained-definition
							    line)
							   line)))
	   (function (for position-list)
		     (uses line definition)
		     (level 10)
		     (definition (pred1 line (:param definition)))))
   (predicates
    (pred1 (line definition)
	    (data~positions line #'(lambda (:protect x)
				     (and (term~constant-p x)
					  (keim~equal (th~definition-constant definition)
						      x)))))
    (pred2 (line definition position-list)
	   (subsetp position-list (pred1 line definition)))
    (func1 (line position-list)
	   (when (every #'(lambda (:protect x) (find x (data~positions line #'term-constant-p) :test #'keim~equal))
			position-list)
	     (find-if
	      #'(lambda (:protect x) (keim~equal (data~struct-at-position line (car position-list))
						 (th~definition-constant x)))
	      (th~definitions-recursed (prob~theory omega*current-proof-plan)))))))
    
   

(dflt~defmatrix defn-contract* tactics
   (agents (c-predicate (for line)
                        (uses )
			(level 3)
                        (definition (not (orules=contained-definition line))))
           (c-predicate (for line)
                        (uses definition)
			(level 10)
                        (definition (pred1 line (:param definition))))
	   (c-predicate (for line)
                        (uses definition position-list)
			(level 5)
                        (definition (pred2 line (:param definition) (:param position-list))))
	   (function (for definition)
		     (uses line)
		     (level 3)
		     (definition (orules=contained-definition line)))
           (function (for definition)
		     (uses line position-list)
		     (level 20)
		     (definition (func1 line (:param position-list))))
	   (function (for position-list)
		     (uses line)
		     (level 3)
		     (definition (data~substruct-positions (orules=contained-definition
							    line)
							   line)))
	   (function (for position-list)
		     (uses line definition)
		     (level 20)
		     (definition (pred1 line (:param definition)))))
   (predicates
    (pred1 (line definition)
	    (data~positions line #'(lambda (:protect x)
				     (and (term~constant-p x)
					  (keim~equal (th~definition-constant definition)
						      x)))))
    (pred2 (line definition position-list)
	   (subsetp position-list (pred1 line definition)))
    (func1 (line position-list)
	   (when (every #'(lambda (:protect x) (find x (data~positions line #'term-constant-p) :test #'keim~equal))
			position-list)
	     (find-if
	      #'(lambda (:protect x) (keim~equal (data~struct-at-position line (car position-list))
						 (th~definition-constant x)))
	      (th~definitions-recursed (prob~theory omega*current-proof-plan)))))))

